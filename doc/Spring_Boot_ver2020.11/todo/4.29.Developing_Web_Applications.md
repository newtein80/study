####29. Developing Web Applications
Spring Boot is well suited for web application development.
Spring Boot는 웹 응용 프로그램 개발에 매우 ​​적합합니다.

You can create a self-contained HTTP server by using embedded Tomcat, Jetty, Undertow, or Netty.
embedded 된 Tomcat, Jetty, Undertow 또는 Netty를 사용하여 자체 포함 된(self-contained) HTTP 서버를 만들 수 있습니다.

Most web applications use the `spring-boot-starter-web` module to get up and running quickly.
대부분의 web applications은 `spring-boot-starter-web` 모듈을 사용하여 빠르게 실행됩니다.

You can also choose to build reactive web applications by using the `spring-boot-starter-webflux` module.
또한 `spring-boot-starter-webflux` 모듈을 사용하여 사후 reactive web applications을 빌드하도록 선택할 수 있습니다.

If you have not yet developed a Spring Boot web application, you can follow the "Hello World!" example in the [Getting started](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-first-application.html) section.
Spring Boot 웹 응용 프로그램을 아직 개발하지 않았다면 [Getting started](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-first-application.html) 섹션 "Hello World!" 예제를 따라하세요.

####29.1 The “Spring Web MVC Framework”
The [Spring Web MVC framework](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc) (often referred to as simply “Spring MVC”) is a rich “model view controller” web framework.
[Spring Web MVC framework](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc) (간단히 "Spring MVC"라고도 함)는 풍부한 "model-view-controller" 웹 프레임 워크입니다.

Spring MVC lets you create special `@Controller` or `@RestController` beans to handle incoming HTTP requests.
Spring MVC는 들어오는 HTTP 요청을 처리하기 위해 특별한 `@Controller` 또는 `@RestController` 빈을 생성하게한다.

Methods in your controller are mapped to HTTP by using `@RequestMappin`g annotations.
컨트롤러의 메서드는 `@RequestMapping` annotation을 사용하여 HTTP에 매핑됩니다.

The following code shows a typical `@RestController` that serves JSON data:
다음 코드는 JSON 데이터를 처리하는 일반적인 `@RestController`를 보여줍니다.

```java
@RestController
@RequestMapping(value="/users")
public class MyRestController {

	@RequestMapping(value="/{user}", method=RequestMethod.GET)
	public User getUser(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
	List<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
	public User deleteUser(@PathVariable Long user) {
		// ...
	}

}
```

Spring MVC is part of the core Spring Framework, and detailed information is available in the [reference documentation](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc).
Spring MVC는 핵심(core) Spring 프레임 워크의 일부이며 자세한 정보는 [참조 문서](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc)에서 확인할 수있다.

There are also several guides that cover Spring MVC available at [spring.io/guides](https://spring.io/guides).
[spring.io/guides](https://spring.io/guides)에서 Spring MVC를 사용 할 수 있는 여러 가이드가 있다.

####29.1.1 Spring MVC Auto-configuration
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
Spring Boot는 대부분의 어플리케이션에서 잘 동작하는 Spring MVC를 위한 자동 설정(auto-configuration) 기능을 제공한다.

The auto-configuration adds the following features on top of Spring’s defaults:
자동 설정(auto-configuration)은 Spring의 기본값 위에 다음과 같은 기능을 추가합니다 :

* Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
`ContentNegotiatingViewResolver`와 `BeanNameViewResolver` 빈을 포함한다.
* Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content))).
WebJars에 대한 지원을 포함하여 정적 자원(static resources) 제공 지원 ([이 문서의 뒷부분](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content)에서 설명)).
* Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.
`Converter`, `GenericConverter` 및 `Formatter` beans의 자동 등록.
* Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-message-converters)).
`HttpMessageConverters` 지원 ([이 문서 뒷부분](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-message-converters)에서 설명).
* Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-message-codes)).
`MessageCodesResolver`의 자동 등록 ([이 문서 뒷부분](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-message-codes)에서 다룹니다).
* Static `index.html` support.
정적 `index.html` 지원.
* Custom `Favicon` support (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-favicon)).
사용자 정의 `Favicon` 지원 ([이 문서 뒷부분](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-favicon)에서 다룹니다).
* Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-web-binding-initializer)).
`ConfigurableWebBindingInitializer` 빈의 자동 사용 ([이 문서 뒷부분](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-web-binding-initializer)에서 설명).

If you want to keep Spring Boot MVC features and you want to add additional [MVC configuration](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but ***without*** `@EnableWebMvc`.
Spring Boot MVC 기능을 유지하고 추가 [MVC 구성](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers 및 기타 기능)을 추가하려는 경우 `@EnableWebMvc`가 ***아닌*** `WebMvcConfigurer` 유형의 `@Configuration` 클래스를 추가 할 수 있습니다.

If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, you can declare a `WebMvcRegistrationsAdapter` instance to provide such components.
`RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` 또는 `ExceptionHandlerExceptionResolver`의 사용자 정의 인스턴스를 제공하려는 경우 `WebMvcRegistrationsAdapter` 인스턴스를 선언하여 이러한 구성 요소를 제공 할 수 있습니다.

If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.
Spring MVC를 완벽하게 제어하려면 `@EnableWebMvc`로 annotation이 달린 `@Configuration`을 추가하면된다.

####29.1.2 HttpMessageConverters
Spring MVC uses the `HttpMessageConverter` interface to convert HTTP requests and responses.
Spring MVC는 HTTP 요청과 응답을 변환하기 위해 `HttpMessageConverter` 인터페이스를 사용한다.

Sensible defaults are included out of the box.
의미있는 기본값이 기본적(out of the box)으로 포함됩니다.

For example, objects can be automatically converted to JSON (by using the Jackson library) or XML (by using the Jackson XML extension, if available, or by using JAXB if the Jackson XML extension is not available).
예를 들어, 객체는 JSON (Jackson 라이브러리를 사용하여) 또는 XML (Jackson XML 확장이 사용 가능한 경우 이를 사용하거나 Jackson XML 확장을 사용할 수없는 경우 JAXB를 사용하여) 로 자동으로 변환 될 수 있음.

By default, strings are encoded in UTF-8.
기본적으로 문자열(strings)은 UTF-8로 인코딩됩니다.

If you need to add or customize converters, you can use Spring Boot’s `HttpMessageConverters` class, as shown in the following listing:
converters를 추가하거나 사용자 정의해야하는 경우 다음 목록과 같이 Spring Boot의 `HttpMessageConverters` 클래스를 사용할 수 있습니다.

```java
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration
public class MyConfiguration {

	@Bean
	public HttpMessageConverters customConverters() {
		HttpMessageConverter<?> additional = ...
		HttpMessageConverter<?> another = ...
		return new HttpMessageConverters(additional, another);
	}

}
```

Any `HttpMessageConverter` bean that is present in the context is added to the list of converters.
컨텍스트에 있는 `HttpMessageConverter` bean이 변환기 목록에 추가됩니다.

You can also override default converters in the same way.
같은 방법으로 기본 converters를 재정의(override) 할 수도 있습니다.

####29.1.3 Custom JSON Serializers and Deserializers
If you use Jackson to serialize and deserialize JSON data, you might want to write your own `JsonSerializer` and `JsonDeserializer` classes.
Jackson을 사용하여 JSON 데이터를 serialize 및 deserialize하는 경우 사용자 고유의 `JsonSerializer` 및 `JsonDeserializer` 클래스를 작성할 수 있습니다.

Custom serializers are usually [registered with Jackson through a module](https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers), but Spring Boot provides an alternative `@JsonComponent` annotation that makes it easier to directly register Spring Beans.
Custom serializers는 일반적으로 [모듈을 통해 Jackson에 등록](https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers)되지만 Spring Boot는 Spring Bean을 직접 등록하기 쉬운 `@JsonComponent` annotation을 제공합니다.

You can use the `@JsonComponent` annotation directly on `JsonSerializer` or `JsonDeserializer` implementations.
`JsonSerializer` 또는 `JsonDeserializer` 구현에서 직접 `@JsonComponent` annotation을 사용할 수 있습니다.

You can also use it on classes that contain serializers/deserializers as inner classes, as shown in the following example:
다음 예제와 같이 내부 클래스로 serializer / deserializers가 포함 된 클래스에서 사용 할 수도 있습니다.

```java
import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

	public static class Serializer extends JsonSerializer<SomeObject> {
		// ...
	}

	public static class Deserializer extends JsonDeserializer<SomeObject> {
		// ...
	}

}
```

All `@JsonComponent` beans in the `ApplicationContext` are automatically registered with Jackson.
`ApplicationContext`의 모든 `@JsonComponent` Bean은 자동으로 Jackson에 등록됩니다.

Because `@JsonComponent` is meta-annotated with `@Component`, the usual component-scanning rules apply.
`@JsonComponent`는 `@Component`로 메타 주석이 붙어 있기(meta-annotated) 때문에 일반적인 구성 요소 검색(component-scan) 규칙이 적용됩니다.

Spring Boot also provides [JsonObjectSerializer](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java) and [JsonObjectDeserializer](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java) base classes that provide useful alternatives to the standard Jackson versions when serializing objects.
Spring Boot는 또한 [JsonObjectSerializer](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java) 및 [JsonObjectDeserializer](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java) 기본 클래스를 제공하여 객체를 직렬화 할 때 표준 Jackson 버전에 대한 유용한 대안을 제공합니다.

See [JsonObjectSerializer](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html) and [JsonObjectDeserializer](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html) in the Javadoc for details.
자세한 내용은 Javadoc의 [JsonObjectSerializer](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html) 및 [JsonObjectDeserializer](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html)를 참조하십시오.

####29.1.4 MessageCodesResolver
Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: `MessageCodesResolver`.
Spring MVC는 바인딩 오류에서 오류 메시지를 렌더링하기 위한 오류 코드를 생성하는 전략을 가지고있다. `MessageCodesResolver`.

If you set the `spring.mvc.message-codes-resolver.format` property `PREFIX_ERROR_CODE` or `POSTFIX_ERROR_CODE`, Spring Boot creates one for you (see the enumeration in [DefaultMessageCodesResolver.Format](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html)).
`spring.mvc.message-codes-resolver.format` 속성을 `PREFIX_ERROR_CODE` 또는 `POSTFIX_ERROR_CODE`로 설정하면 Spring Boot가 자동으로 생성합니다 ([DefaultMessageCodesResolver.Format](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html)의 열거 참조).

####29.1.5 Static Content
By default, Spring Boot serves static content from a directory called `/static` (or `/public` or `/resources` or `/META-INF/resources`) in the classpath or from the root of the `ServletContext`.
기본적으로 Spring Boot는 classpath 또는 `ServletContext` 루트에서 `/ static` (또는 `/ public` 또는 `/ resources` 또는 `/ META-INF / resources`) 디렉토리의 정적 컨텐츠를 제공합니다.

It uses the `ResourceHttpRequestHandler` from Spring MVC so that you can modify that behavior by adding your own `WebMvcConfigurer` and overriding the `addResourceHandlers` method.
Spring MVC의 `ResourceHttpRequestHandler`를 사용하여 자신 만의 `WebMvcConfigurer`를 추가하고 `addResourceHandlers` 메서드를 재정의(overriding)하여 해당 동작을 수정할 수 있습니다.

In a stand-alone web application, the default servlet from the container is also enabled and acts as a fallback, serving content from the root of the `ServletContext` if Spring decides not to handle it.
<span style="color:Red">독립형 웹 응용 프로그램에서 컨테이너의 기본 서블릿도 활성화되어 Spring에서 처리하지 않기로 결정한 경우 `ServletContext`의 루트에서 컨텐트를 제공하는 대체 역할을합니다.</span>

Most of the time, this does not happen (unless you modify the default MVC configuration), because Spring can always handle requests through the `DispatcherServlet`.
Spring이 항상 `DispatcherServlet`을 통해 요청을 처리 할 수 ​​있기 때문에 대부분의 경우 이 작업은 수행되지 않습니다 (기본 MVC 구성을 수정하지 않는 한).

By default, resources are mapped on `/**`, but you can tune that with the `spring.mvc.static-path-pattern` property.
기본적으로 리소스는 `/**`에 매핑되지만 `spring.mvc.static-path-pattern` 속성을 사용하여 튜닝 할 수 있습니다. 

For instance, relocating all resources to `/resources/**` can be achieved as follows:
예를 들어, 모든 리소스를 `/ resources / **`로 재배치하는 것은 다음과 같이 수행 할 수 있습니다.

```properties
spring.mvc.static-path-pattern=/resources/**
```

You can also customize the static resource locations by using the `spring.resources.static-locations` property (replacing the default values with a list of directory locations).
`spring.resources.static-locations` 등록 정보 (기본값을 디렉토리 위치 목록으로 바꾸기)를 사용하여 정적 자원 위치를 사용자 정의 할 수도 있습니다.

The root Servlet context path, `"/"`, is automatically added as a location as well.
루트 서블릿 컨텍스트 경로 `"/"`가 위치로 자동 추가됩니다.

In addition to the “standard” static resource locations mentioned earlier, a special case is made for [Webjars content](https://www.webjars.org/).
앞서 언급 한 “standard” 정적 리소스 위치 외에도 [Webjars 콘텐츠](https://www.webjars.org/)에 특별한 경우가 있습니다.

Any resources with a path in `/webjars/**` are served from jar files if they are packaged in the Webjars format.
`/ webjars / **`에 경로가 있는 자원은 Webjars 형식으로 패키지 된 경우 jar 파일에서 제공됩니다.

>:bulb:
Do not use the `src/main/webapp` directory if your application is packaged as a jar.
응용 프로그램이 jar로 패키지화 되어 있는 경우 `src / main / webapp` 디렉토리를 사용하지 마십시오.
Although this directory is a common standard, it works **only** with war packaging, and it is silently ignored by most build tools if you generate a jar.
이 디렉토리는 일반적인 표준이지만, war 패키징에서**만** 작동하며 jar 파일을 생성하면 대부분의 빌드 도구에서 자동으로 무시됩니다.

Spring Boot also supports the advanced resource handling features provided by Spring MVC, allowing use cases such as cache-busting static resources or using version agnostic URLs for Webjars.
<span style="color:Red">Spring Boot는 또한 Spring MVC가 제공하는 고급 리소스 처리 기능을 지원하므로 캐시 무효화 정적 리소스(cache-busting static resources) 또는 Webjars 용 버전 불가지론 URL 사용과 같은 사용(== Webjars에 대해 버전에 관계없는 URL) 사례를 허용합니다.</span>

To use version agnostic URLs for Webjars, add the `webjars-locator-core` dependency.
Webjars에 대해 버전에 관계없는 URL을 사용하려면 `webjars-locator-core` 종속성을 추가하십시오.

Then declare your Webjar. Using jQuery as an example, adding `"/webjars/jquery/jquery.min.js"` results in `"/webjars/jquery/x.y.z/jquery.min.js"`. where `x.y.z` is the Webjar version.
그런 Webjar를 선언하십시오. 예를 들어 jQuery를 사용하면 `"/webjars/jquery/jquery.min.js"`를 추가하면 `"/webjars/jquery/x.y.z/jquery.min.js"`가 됩니다. 여기서 `x.y.z`는 Webjar 버전입니다.

>:bulb:
If you use JBoss, you need to declare the `webjars-locator-jboss-vfs` dependency instead of the `webjars-locator-core`.
JBoss를 사용하는 경우 `webjars-locator-core` 대신 `webjars-locator-jboss-vfs` 종속성을 선언해야합니다.
Otherwise, all Webjars resolve as a `404`.
그렇지 않으면 모든 Webjars가 `404`로 해결됩니다.

To use cache busting, the following configuration configures a cache busting solution for all static resources, effectively adding a content hash, such as `<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`, in URLs:
캐시 무효화를 사용하기 위해 다음 구성에서는 모든 정적 리소스에 대한 캐시 무효화 솔루션(cache busting solution)을 구성하여 URL에 `<link href = "/ css / spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`와 같은 콘텐츠 해시(hash)를 효과적으로 추가합니다.

```properties
spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
```

>:bulb:
Links to resources are rewritten in templates at runtime, thanks to a `ResourceUrlEncodingFilter` that is auto-configured for Thymeleaf and FreeMarker.
리소스 링크는 Thymeleaf 및 FreeMarker에 대해 자동 구성되는 `ResourceUrlEncodingFilter` 덕분에 런타임에 템플릿에 다시 작성됩니다.
You should manually declare this filter when using JSPs.
JSP를 사용할 때 이 필터를 수동으로 선언해야 합니다.
Other template engines are currently not automatically supported but can be with custom template macros/helpers and the use of the [ResourceUrlProvider](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html).
다른 템플릿 엔진은 현재 자동으로 지원되지 않지만 사용자 지정 템플릿 매크로 / 도우미와 [ResourceUrlProvider](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html)를 사용할 수 있습니다.

When loading resources dynamically with, for example, a JavaScript module loader, renaming files is not an option.
예를 들어 자바 스크립트 모듈 로더와 같이 리소스를 동적으로 로드 할 때 파일 이름 바꾸기는 옵션이 아닙니다.

That is why other strategies are also supported and can be combined.
그래서 다른 전략도 지원되고 결합 될 수 있습니다.

A "fixed" strategy adds a static version string in the URL without changing the file name, as shown in the following example:
"fixed" 전략은 다음 예와 같이 파일 이름을 변경하지 않고 URL에 정적 버전 문자열을 추가합니다.

```properties
spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12
```

With this configuration, JavaScript modules located under `"/js/lib/"` use a fixed versioning strategy (`"/v12/js/lib/mymodule.js"`), while other resources still use the content one (`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`).
이 구성을 사용하면 `"/ js / lib /"` 아래에 있는 JavaScript 모듈은 고정 된 버전 관리 전략 ( `"/v12/js/lib/mymodule.js"`)을 사용하지만 다른 리소스는 여전히 내용 하나입니다. (`<link href = "/ css / spring-2a2d595e6ed9a0b24f027f2b63b134d6.css "/>`).

See [ResourceProperties](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java) for more supported options.
지원되는 옵션에 대해서는 [ResourceProperties](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java)를 참조하십시오.

>:bulb:
This feature has been thoroughly described in a dedicated [blog post](https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources) and in Spring Framework’s [reference documentation](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources).
이 기능은 전용 [블로그 포스트](https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources)와 Spring Framework의 [참조 문서](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources)에 자세히 설명되어 있습니다.

####29.1.6 Welcome Page
Spring Boot supports both static and templated welcome pages.
Spring Boot는 정적 및 템플리트 된 welcome 페이지를 모두 지원합니다.

It first looks for an `index.html` file in the configured static content locations.
구성된 정적 컨텐츠 위치에서 `index.html` 파일을 먼저 찾습니다.

If one is not found, it then looks for an `index` template.
하나도 찾지 못하면 `index` 템플릿을 찾습니다.

If either is found, it is automatically used as the welcome page of the application.
둘 중 하나가 발견되면 자동으로 응용 프로그램의 시작 페이지로 사용됩니다.

####29.1.7 Custom Favicon
Spring Boot looks for a `favicon.ico` in the configured static content locations and the root of the classpath (in that order).
Spring Boot는 구성된 정적 컨텐츠 위치와 classpath의 루트 (순서대로)에서 `favicon.ico`를 찾습니다.

If such a file is present, it is automatically used as the favicon of the application.
이러한 파일이 있는 경우 자동으로 응용 프로그램의 favicon으로 사용됩니다.

####29.1.8 Path Matching and Content Negotiation
Spring MVC can map incoming HTTP requests to handlers by looking at the request path and matching it to the mappings defined in your application (for example, `@GetMapping` annotations on Controller methods).
Spring MVC는 요청 경로를 보고 애플리케이션에 정의 된 매핑 (예 : 컨트롤러 메소드의 `@GetMapping` annotation)과 일치시켜 들어오는 HTTP 요청을 핸들러에 매핑 할 수있다.

Spring Boot chooses to disable suffix pattern matching by default, which means that requests like `"GET /projects/spring-boot.json"` ***won’t be matched*** to `@GetMapping("/projects/spring-boot")` mappings.
Spring Boot는 기본적으로 접미사 패턴 일치를 비활성화하도록 선택합니다. `"GET /projects/spring-boot.json"`과 같은 요청은 `@GetMapping ( "/ projects / spring-boot")` 매핑과 ***일치하지 않습니다***.

This is considered as a [best practice for Spring MVC applications](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match).
이것은 [Spring MVC 애플리케이션을 위한 모범 사례](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match)로 간주된다.

<span style="color:Red">This feature was mainly useful in the past for HTTP clients which did not send proper "Accept" request headers; we needed to make sure to send the correct Content Type to the client.
이 기능은 적절한 "Accept"요청 헤더를 보내지 않은 HTTP 클라이언트에 대해 과거에는 주로 유용했습니다. 우리는 올바른 Content Type을 클라이언트에 보내야합니다.</span>

<span style="color:Red">Nowadays, Content Negotiation is much more reliable.
요즘, 콘텐츠 협상(Negotiation)은 훨씬 더 신뢰할 수 있습니다.</span>

There are other ways to deal with HTTP clients that don’t consistently send proper "Accept" request headers.
적절한 "Accept" 요청 헤더를 지속적으로 보내지 않는 HTTP 클라이언트를 다룰 수 있는 다른 방법이 있습니다.

Instead of using suffix matching, we can use a query parameter to ensure that requests like "GET /projects/spring-boot?format=json" will be mapped to @GetMapping("/projects/spring-boot"):
접미어 일치를 사용하는 대신 `"GET / projects / spring-boot? format = json"`과 같은 요청이 `@GetMapping ( "/ projects / spring-boot")`에 매핑되도록 쿼리 매개 변수를 사용할 수 있습니다.

```properties
spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown
```

If you understand the caveats and would still like your application to use suffix pattern matching, the following configuration is required:
주의 사항을 이해하고 여전히 접미어 패턴 일치를 사용하려는 응용 프로그램을 원한다면 다음 구성이 필요합니다.

```properties
spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-suffix-pattern=true
```

Alternatively, rather than open all suffix patterns, it’s more secure to just support registered suffix patterns:
또는 모든 접미어 패턴을 열지 않고 등록 된 접미사 패턴을 지원하는 것이 더 안전합니다.

```properties
spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc
```

####29.1.9 ConfigurableWebBindingInitializer
Spring MVC uses a `WebBindingInitializer` to initialize a `WebDataBinder` for a particular request.
Spring MVC는 `WebBindingInitializer`를 사용하여 특정 요청에 대해 `WebDataBinder`를 초기화한다.

If you create your own `ConfigurableWebBindingInitializer` `@Bean`, Spring Boot automatically configures Spring MVC to use it.
나만의 `ConfigurableWebBindingInitializer` `@Bean`을 생성하면, Spring Boot는이를 사용하기 위해 Spring MVC를 자동으로 설정합니다.

####29.1.10 Template Engines
As well as REST web services, you can also use Spring MVC to serve dynamic HTML content.
REST 웹 서비스뿐만 아니라 Spring MVC를 사용하여 동적 HTML 컨텐츠를 제공 할 수 도있다.

Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, and JSPs.
Spring MVC는 Thymeleaf, FreeMarker 및 JSP를 비롯한 다양한 템플릿 기술을 지원합니다.

Also, many other templating engines include their own Spring MVC integrations.
또한 많은 다른 템플릿 엔진에는 자체적 인 Spring MVC 통합이 포함됩니다.

Spring Boot includes auto-configuration support for the following templating engines:
Spring Boot는 다음 템플릿 엔진에 대한 자동 구성 지원을 포함합니다.

* [FreeMarker](https://freemarker.apache.org/docs/)
* [Groovy](http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine)
* [Thymeleaf](https://www.thymeleaf.org/)
* [Mustache](https://mustache.github.io/)

>:bulb:
If possible, JSPs should be avoided.
가능한 경우 JSP를 피해야합니다.
There are several known limitations when using them with embedded servlet containers.
임베디드 서블릿 컨테이너에서 사용할 때 몇 가지 [알려진 제한 사항](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations)이 있습니다.

When you use one of these templating engines with the default configuration, your templates are picked up automatically from `src/main/resources/templates`.
이 템플릿 엔진 중 하나를 기본 구성으로 사용하면 템플릿이 `src / main / resources / templates`에서 자동으로 선택됩니다.

>:bulb:
Depending on how you run your application, IntelliJ IDEA orders the classpath differently.
응용 프로그램을 실행하는 방법에 따라 IntelliJ IDEA는 클래스 경로를 다르게 정렬합니다.
Running your application in the IDE from its main method results in a different ordering than when you run your application by using Maven or Gradle or from its packaged jar.
main method에서 IDE에서 응용 프로그램을 실행하면 Maven 또는 Gradle을 사용하거나 응용 프로그램을 실행할 때와 패키지 순서가 다릅니다.
This can cause Spring Boot to fail to find the templates on the classpath.
이로 인해 Spring Boot가 classpath에서 템플릿을 찾지 못하게 될 수 있습니다.
If you have this problem, you can reorder the classpath in the IDE to place the module’s classes and resources first.
이 문제가 발생하면 IDE의 classpath를 재정렬하여 모듈의 클래스와 리소스를 먼저 배치 할 수 있습니다.
Alternatively, you can configure the template prefix to search every `templates` directory on the classpath, as follows: `classpath*:/templates/`.
또는 `classpath * : / templates /`과 같이 classpath의 모든 `templates` 디렉토리를 검색하도록 template 접두사를 구성 할 수 있습니다.

####29.1.11 Error Handling
By default, Spring Boot provides an `/error` mapping that handles all errors in a sensible way, and it is registered as a “global” error page in the servlet container.
기본적으로 Spring Boot는 모든 오류를 적절한 방식으로 처리하는 `/error` 매핑을 제공하며 서블릿 컨테이너에 "전역"오류 페이지로 등록됩니다.

For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message.
시스템 클라이언트의 경우, 오류, HTTP 상태 및 예외 메시지와 함께 JSON 응답을 생성합니다.

<span style="color:Red">For browser clients, there is a “whitelabel” error view that renders the same data in HTML format (to customize it, add a `View` that resolves to `error`).
브라우저 클라이언트의 경우, 동일한 데이터를 HTML 형식으로 렌더링하는 “whitelabel”오류 보기가 있습니다 (customize 하고, `error`를 해결하기 위한 `View`를 추가하는 ).</span>

To replace the default behavior completely, you can implement ErrorController and register a bean definition of that type or add a bean of type ErrorAttributes to use the existing mechanism but replace the contents.
기본 동작을 완전히 바꾸려면 `ErrorController`를 구현하고 해당 유형의 Bean 정의를 등록하거나 `ErrorAttributes` 유형의 Bean을 추가하여 기존 메커니즘을 사용하지만 내용을 대체하십시오.

>:bulb:
The `BasicErrorController` can be used as a base class for a custom `ErrorController`.
`BasicErrorController`는 사용자 정의 `ErrorController`의 기본 클래스로 사용할 수 있습니다.
This is particularly useful if you want to add a handler for a new content type (the default is to handle `text/html` specifically and provide a fallback for everything else).
이 기능은 새 content type에 대한 처리기를 추가하려는 경우에 특히 유용합니다. (기본값은 `text / html`을 구체적으로 처리하고 다른 모든 항목에 대체 기능을 제공하는 것입니다.)
To do so, extend `BasicErrorController`, add a public method with a `@RequestMapping` that has a `produces` attribute, and create a bean of your new type.
이렇게하려면 `BasicErrorController`를 확장하고 `produce` 속성이있는 `@RequestMapping`이 있는 공용 메서드를 추가 한 다음 새 유형의 Bean을 만듭니다.

You can also define a class annotated with `@ControllerAdvice` to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example:
다음 예제와 같이 `@ControllerAdvice` annotation으로 주석 된 클래스를 정의하여 특정 컨트롤러 및 / 또는 예외 유형에 대해 반환 할 JSON 문서를 사용자 정의 할 수도 있습니다.

```java
@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

	@ExceptionHandler(YourException.class)
	@ResponseBody
	ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
		HttpStatus status = getStatus(request);
		return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
	}

	private HttpStatus getStatus(HttpServletRequest request) {
		Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
		if (statusCode == null) {
			return HttpStatus.INTERNAL_SERVER_ERROR;
		}
		return HttpStatus.valueOf(statusCode);
	}

}
```

In the preceding example, if `YourException` is thrown by a controller defined in the same package as `AcmeController`, a JSON representation of the `CustomErrorType` POJO is used instead of the `ErrorAttributes` representation.
앞의 예에서 `YourException`이 `AcmeController`와 동일한 패키지에 정의 된 컨트롤러에 의해 throw 된 경우 `CustomArrorType` POJO의 JSON 표현이 `ErrorAttributes` 표현 대신 사용됩니다.

#####Custom Error Pages
If you want to display a custom HTML error page for a given status code, you can add a file to an `/error` folder.
주어진 상태 코드에 대한 사용자 정의 HTML 오류 페이지를 표시하려면 `/ error` 폴더에 파일을 추가하십시오.

Error pages can either be static HTML (that is, added under any of the static resource folders) or be built by using templates.
오류 페이지는 정적 HTML (정적 리소스 폴더 아래에 추가 된)이거나 템플릿을 사용하여 빌드 될 수 있습니다.

The name of the file should be the exact status code or a series mask.
파일의 이름은 정확한 상태 코드 또는 시리즈 마스크(series mask) 여야합니다.

For example, to map `404` to a static HTML file, your folder structure would be as follows:
예를 들어 `404`를 정적 HTML 파일에 매핑하려면 폴더 구조가 다음과 같습니다.

```
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- <other public assets>
```
To map all `5xx` errors by using a FreeMarker template, your folder structure would be as follows:
FreeMarker 템플릿을 사용하여 `5xx` 오류를 모두 매핑하려면 폴더 구조가 다음과 같습니다.

```
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftl
             +- <other templates>
```

For more complex mappings, you can also add beans that implement the `ErrorViewResolver` interface, as shown in the following example:
보다 복잡한 매핑의 경우 다음 예제와 같이 `ErrorViewResolver` 인터페이스를 구현하는 bean을 추가 할 수도 있습니다.

```java
public class MyErrorViewResolver implements ErrorViewResolver {

	@Override
	public ModelAndView resolveErrorView(HttpServletRequest request,
			HttpStatus status, Map<String, Object> model) {
		// Use the request or status to optionally return a ModelAndView
		return ...
	}

}
```

You can also use regular Spring MVC features such as [@ExceptionHandler methods](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers) and [@ControllerAdvice](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice).
또한 [@ExceptionHandler methods](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers) 메소드와 [@ControllerAdvice](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice).와 같은 일반적인 Spring MVC 기능을 사용할 수 있습니다.

The `ErrorController` then picks up any unhandled exceptions.
그런 다음 `ErrorController`는 처리되지 않은 예외를 선택합니다.

#####Mapping Error Pages outside of Spring MVC
For applications that do not use Spring MVC, you can use the `ErrorPageRegistrar` interface to directly register `ErrorPages`.
Spring MVC를 사용하지 않는 응용 프로그램의 경우 `ErrorPageRegistrar` 인터페이스를 사용하여 `ErrorPages`를 직접 등록 할 수 있습니다.

This abstraction works directly with the underlying embedded servlet container and works even if you do not have a Spring MVC `DispatcherServlet`.
이 추상화는 기본 내장 된 서블릿 컨테이너와 직접 작동하며 Spring MVC `DispatcherServlet`이 없어도 작동합니다.

```java
@Bean
public ErrorPageRegistrar errorPageRegistrar(){
	return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

	@Override
	public void registerErrorPages(ErrorPageRegistry registry) {
		registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
	}

}
```

>:bulb:
If you register an `ErrorPage` with a path that ends up being handled by a `Filter` (as is common with some non-Spring web frameworks, like Jersey and Wicket), then the `Filter` has to be explicitly registered as an ERROR dispatcher, as shown in the following example:
Jersey와 Wicket과 같은 일부 non-Spring 웹 프레임 워크에서 일반적인 것처럼 `Filter`에 의해 처리되는 경로로 `ErrorPage`를 등록하면 `Filter`는 다음과 같이 ERROR dispatcher로 명시 적으로 등록되어야합니다.

```java
@Bean
public FilterRegistrationBean myFilter() {
	FilterRegistrationBean registration = new FilterRegistrationBean();
	registration.setFilter(new MyFilter());
	...
	registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
	return registration;
}
```

Note that the default `FilterRegistrationBean` does not include the `ERROR` dispatcher type.
기본 `FilterRegistrationBean`에는 `ERROR` dispatcher 유형이 포함되어 있지 않습니다.

CAUTION:
When deployed to a servlet container, Spring Boot uses its error page filter to forward a request with an error status to the appropriate error page.
SpringBoot는 서블릿 컨테이너에 배포 할 때 오류 페이지 필터를 사용하여 오류 상태의 요청을 해당 오류 페이지로 전달합니다.
The request can only be forwarded to the correct error page if the response has not already been committed.
응답이 아직 커밋되지 않은 경우에만 요청을 올바른 오류 페이지로 전달할 수 있습니다.
By default, WebSphere Application Server 8.0 and later commits the response upon successful completion of a servlet’s service method.
기본적으로 WebSphere Application Server 8.0 이상은 서블릿의 서비스 메소드 완료시 응답을 커밋합니다.
You should disable this behavior by setting `com.ibm.ws.webcontainer.invokeFlushAfterService` to `false`.
`com.ibm.ws.webcontainer.invokeFlushAfterService`를 `false`로 설정하여이 작동을 사용 불가능하게 해야합니다.

####29.1.12 Spring HATEOAS
If you develop a RESTful API that makes use of hypermedia, Spring Boot provides auto-configuration for Spring HATEOAS that works well with most applications. The auto-configuration replaces the need to use @EnableHypermediaSupport and registers a number of beans to ease building hypermedia-based applications, including a LinkDiscoverers (for client side support) and an ObjectMapper configured to correctly marshal responses into the desired representation. The ObjectMapper is customized by setting the various spring.jackson.* properties or, if one exists, by a Jackson2ObjectMapperBuilder bean.

You can take control of Spring HATEOAS’s configuration by using @EnableHypermediaSupport. Note that doing so disables the ObjectMapper customization described earlier.

####29.1.13 CORS Support
Cross-origin resource sharing (CORS) is a W3C specification implemented by most browsers that lets you specify in a flexible way what kind of cross-domain requests are authorized, instead of using some less secure and less powerful approaches such as IFRAME or JSONP.

As of version 4.2, Spring MVC supports CORS. Using controller method CORS configuration with @CrossOrigin annotations in your Spring Boot application does not require any specific configuration. Global CORS configuration can be defined by registering a WebMvcConfigurer bean with a customized addCorsMappings(CorsRegistry) method, as shown in the following example:

@Configuration
public class MyConfiguration {

	@Bean
	public WebMvcConfigurer corsConfigurer() {
		return new WebMvcConfigurer() {
			@Override
			public void addCorsMappings(CorsRegistry registry) {
				registry.addMapping("/api/**");
			}
		};
	}
}

####29.2 The “Spring WebFlux Framework” <U>(추후 사용예정....)</U>
Spring WebFlux is the new reactive web framework introduced in Spring Framework 5.0. Unlike Spring MVC, it does not require the Servlet API, is fully asynchronous and non-blocking, and implements the Reactive Streams specification through the Reactor project.

Spring WebFlux comes in two flavors: functional and annotation-based. The annotation-based one is quite close to the Spring MVC model, as shown in the following example:

```java
@RestController
@RequestMapping("/users")
public class MyRestController {

	@GetMapping("/{user}")
	public Mono<User> getUser(@PathVariable Long user) {
		// ...
	}

	@GetMapping("/{user}/customers")
	public Flux<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}

	@DeleteMapping("/{user}")
	public Mono<User> deleteUser(@PathVariable Long user) {
		// ...
	}

}
```

“WebFlux.fn”, the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example:

```java
@Configuration
public class RoutingConfiguration {

	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
		return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
				.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
				.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
	}

}

@Component
public class UserHandler {

	public Mono<ServerResponse> getUser(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> deleteUser(ServerRequest request) {
		// ...
	}
}
```

WebFlux is part of the Spring Framework and detailed information is available in its reference documentation.

[Tip]
You can define as many RouterFunction beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence.

To get started, add the spring-boot-starter-webflux module to your application.

[Note]
Adding both spring-boot-starter-web and spring-boot-starter-webflux modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add spring-boot-starter-webflux to their Spring MVC application to use the reactive WebClient. You can still enforce your choice by setting the chosen application type to SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE).

####29.2.1 Spring WebFlux Auto-configuration <U>(추후 사용예정....)</U>
Spring Boot provides auto-configuration for Spring WebFlux that works well with most applications.

The auto-configuration adds the following features on top of Spring’s defaults:

Configuring codecs for HttpMessageReader and HttpMessageWriter instances (described later in this document).
Support for serving static resources, including support for WebJars (described later in this document).
If you want to keep Spring Boot WebFlux features and you want to add additional WebFlux configuration, you can add your own @Configuration class of type WebFluxConfigurer but without @EnableWebFlux.

If you want to take complete control of Spring WebFlux, you can add your own @Configuration annotated with @EnableWebFlux.

####29.2.2 HTTP Codecs with HttpMessageReaders and HttpMessageWriters <U>(추후 사용예정....)</U>
Spring WebFlux uses the HttpMessageReader and HttpMessageWriter interfaces to convert HTTP requests and responses. They are configured with CodecConfigurer to have sensible defaults by looking at the libraries available in your classpath.

Spring Boot applies further customization by using CodecCustomizer instances. For example, spring.jackson.* configuration keys are applied to the Jackson codec.

If you need to add or customize codecs, you can create a custom CodecCustomizer component, as shown in the following example:

```java
import org.springframework.boot.web.codec.CodecCustomizer;

@Configuration
public class MyConfiguration {

	@Bean
	public CodecCustomizer myCodecCustomizer() {
		return codecConfigurer -> {
			// ...
		}
	}

}
```

You can also leverage Boot’s custom JSON serializers and deserializers.

####29.2.3 Static Content <U>(추후 사용예정....)</U>
By default, Spring Boot serves static content from a directory called /static (or /public or /resources or /META-INF/resources) in the classpath. It uses the ResourceWebHandler from Spring WebFlux so that you can modify that behavior by adding your own WebFluxConfigurer and overriding the addResourceHandlers method.

By default, resources are mapped on /**, but you can tune that by setting the spring.webflux.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows:

spring.webflux.static-path-pattern=/resources/**
You can also customize the static resource locations by using spring.resources.static-locations. Doing so replaces the default values with a list of directory locations. If you do so, the default welcome page detection switches to your custom locations. So, if there is an index.html in any of your locations on startup, it is the home page of the application.

In addition to the “standard” static resource locations listed earlier, a special case is made for Webjars content. Any resources with a path in /webjars/** are served from jar files if they are packaged in the Webjars format.

[Tip]
Spring WebFlux applications do not strictly depend on the Servlet API, so they cannot be deployed as war files and do not use the src/main/webapp directory.

####29.2.4 Template Engines <U>(추후 사용예정....)</U>
As well as REST web services, you can also use Spring WebFlux to serve dynamic HTML content. Spring WebFlux supports a variety of templating technologies, including Thymeleaf, FreeMarker, and Mustache.

Spring Boot includes auto-configuration support for the following templating engines:

FreeMarker
Thymeleaf
Mustache
When you use one of these templating engines with the default configuration, your templates are picked up automatically from src/main/resources/templates.

####29.2.5 Error Handling <U>(추후 사용예정....)</U>
Spring Boot provides a WebExceptionHandler that handles all errors in a sensible way. Its position in the processing order is immediately before the handlers provided by WebFlux, which are considered last. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error handler that renders the same data in HTML format. You can also provide your own HTML templates to display errors (see the next section).

The first step to customizing this feature often involves using the existing mechanism but replacing or augmenting the error contents. For that, you can add a bean of type ErrorAttributes.

To change the error handling behavior, you can implement ErrorWebExceptionHandler and register a bean definition of that type. Because a WebExceptionHandler is quite low-level, Spring Boot also provides a convenient AbstractErrorWebExceptionHandler to let you handle errors in a WebFlux functional way, as shown in the following example:

```java
public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

	// Define constructor here

	@Override
	protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

		return RouterFunctions
				.route(aPredicate, aHandler)
				.andRoute(anotherPredicate, anotherHandler);
	}

}
```

For a more complete picture, you can also subclass DefaultErrorWebExceptionHandler directly and override specific methods.

Custom Error Pages
If you want to display a custom HTML error page for a given status code, you can add a file to an /error folder. Error pages can either be static HTML (that is, added under any of the static resource folders) or built with templates. The name of the file should be the exact status code or a series mask.

For example, to map 404 to a static HTML file, your folder structure would be as follows:

```
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- <other public assets>
```

To map all 5xx errors by using a Mustache template, your folder structure would be as follows:

```
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- <other templates>
```

####29.2.6 Web Filters <U>(추후 사용예정....)</U>
Spring WebFlux provides a WebFilter interface that can be implemented to filter HTTP request-response exchanges. WebFilter beans found in the application context will be automatically used to filter each exchange.

Where the order of the filters is important they can implement Ordered or be annotated with @Order. Spring Boot auto-configuration may configure web filters for you. When it does so, the orders shown in the following table will be used:

| Web Filter  | Order  |
|---|---|
| `MetricsWebFilter`  | `Ordered.HIGHEST_PRECEDENCE + 1`  |
| `WebFilterChainProxy` (Spring Security)  | `-100`  |
| `HttpTraceWebFilter`  | `Ordered.LOWEST_PRECEDENCE - 10`  |

####29.3 JAX-RS and Jersey <U>(추후 사용예정....)</U>
If you prefer the JAX-RS programming model for REST endpoints, you can use one of the available implementations instead of Spring MVC. Jersey and Apache CXF work quite well out of the box. CXF requires you to register its Servlet or Filter as a @Bean in your application context. Jersey has some native Spring support, so we also provide auto-configuration support for it in Spring Boot, together with a starter.

To get started with Jersey, include the spring-boot-starter-jersey as a dependency and then you need one @Bean of type ResourceConfig in which you register all the endpoints, as shown in the following example:

```java
@Component
public class JerseyConfig extends ResourceConfig {

	public JerseyConfig() {
		register(Endpoint.class);
	}

}
```

[Warning]
Jersey’s support for scanning executable archives is rather limited. For example, it cannot scan for endpoints in a package found in a fully executable jar file or in WEB-INF/classes when running an executable war file. To avoid this limitation, the packages method should not be used, and endpoints should be registered individually by using the register method, as shown in the preceding example.

For more advanced customizations, you can also register an arbitrary number of beans that implement ResourceConfigCustomizer.

All the registered endpoints should be @Components with HTTP resource annotations (@GET and others), as shown in the following example:

```java
@Component
@Path("/hello")
public class Endpoint {

	@GET
	public String message() {
		return "Hello";
	}

}
```

Since the Endpoint is a Spring @Component, its lifecycle is managed by Spring and you can use the @Autowired annotation to inject dependencies and use the @Value annotation to inject external configuration. By default, the Jersey servlet is registered and mapped to /*. You can change the mapping by adding @ApplicationPath to your ResourceConfig.

By default, Jersey is set up as a Servlet in a @Bean of type ServletRegistrationBean named jerseyServletRegistration. By default, the servlet is initialized lazily, but you can customize that behavior by setting spring.jersey.servlet.load-on-startup. You can disable or override that bean by creating one of your own with the same name. You can also use a filter instead of a servlet by setting spring.jersey.type=filter (in which case, the @Bean to replace or override is jerseyFilterRegistration). The filter has an @Order, which you can set with spring.jersey.filter.order. Both the servlet and the filter registrations can be given init parameters by using spring.jersey.init.* to specify a map of properties.

There is a Jersey sample so that you can see how to set things up.

####29.4 Embedded Servlet Container Support <U>(추후 사용예정....)</U>
Spring Boot includes support for embedded Tomcat, Jetty, and Undertow servers. Most developers use the appropriate “Starter” to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080.

####29.4.1 Servlets, Filters, and listeners <U>(추후 사용예정....)</U>
When using an embedded servlet container, you can register servlets, filters, and all the listeners (such as HttpSessionListener) from the Servlet spec, either by using Spring beans or by scanning for Servlet components.

Registering Servlets, Filters, and Listeners as Spring Beans
Any Servlet, Filter, or servlet *Listener instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your application.properties during configuration.

By default, if the context contains only a single Servlet, it is mapped to /. In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to /*.

If convention-based mapping is not flexible enough, you can use the ServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean classes for complete control.

Spring Boot ships with many auto-configurations that may define Filter beans. Here are a few examples of Filters and their respective order (lower order value means higher precedence):

| Servlet Filter  | Order  |
|---|---|
| `OrderedCharacterEncodingFilter`  | `Ordered.HIGHEST_PRECEDENCE`  |
| `WebMvcMetricsFilter` | `Ordered.HIGHEST_PRECEDENCE + 1`  |
| `ErrorPageFilter`  | `Ordered.HIGHEST_PRECEDENCE + 1`  |
| `HttpTraceFilter`  | `Ordered.LOWEST_PRECEDENCE - 10`  |

It is usually safe to leave Filter beans unordered.

If a specific order is required, you should avoid configuring a Filter that reads the request body at Ordered.HIGHEST_PRECEDENCE, since it might go against the character encoding configuration of your application. If a Servlet filter wraps the request, it should be configured with an order that is less than or equal to OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER.

####29.4.2 Servlet Context Initialization <U>(추후 사용예정....)</U>
Embedded servlet containers do not directly execute the Servlet 3.0+ javax.servlet.ServletContainerInitializer interface or Spring’s org.springframework.web.WebApplicationInitializer interface. This is an intentional design decision intended to reduce the risk that third party libraries designed to run inside a war may break Spring Boot applications.

If you need to perform servlet context initialization in a Spring Boot application, you should register a bean that implements the org.springframework.boot.web.servlet.ServletContextInitializer interface. The single onStartup method provides access to the ServletContext and, if necessary, can easily be used as an adapter to an existing WebApplicationInitializer.

#####Scanning for Servlets, Filters, and listeners
When using an embedded container, automatic registration of classes annotated with @WebServlet, @WebFilter, and @WebListener can be enabled by using @ServletComponentScan.

[Tip]
@ServletComponentScan has no effect in a standalone container, where the container’s built-in discovery mechanisms are used instead.

####29.4.3 The ServletWebServerApplicationContext <U>(추후 사용예정....)</U>
Under the hood, Spring Boot uses a different type of ApplicationContext for embedded servlet container support. The ServletWebServerApplicationContext is a special type of WebApplicationContext that bootstraps itself by searching for a single ServletWebServerFactory bean. Usually a TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory has been auto-configured.

[Note]
You usually do not need to be aware of these implementation classes. Most applications are auto-configured, and the appropriate ApplicationContext and ServletWebServerFactory are created on your behalf.

####29.4.4 Customizing Embedded Servlet Containers <U>(추후 사용예정....)</U>
Common servlet container settings can be configured by using Spring Environment properties. Usually, you would define the properties in your application.properties file.

Common server settings include:

* Network settings: Listen port for incoming HTTP requests (server.port), interface address to bind to server.address, and so on.
* Session settings: Whether the session is persistent (server.servlet.session.persistence), session timeout (server.servlet.session.timeout), location of session data (server.servlet.session.store-dir), and session-cookie configuration (server.servlet.session.cookie.*).
* Error management: Location of the error page (server.error.path) and so on.
* SSL
* HTTP compression

Spring Boot tries as much as possible to expose common settings, but this is not always possible. For those cases, dedicated namespaces offer server-specific customizations (see server.tomcat and server.undertow). For instance, access logs can be configured with specific features of the embedded servlet container.

[Tip]
See the ServerProperties class for a complete list.

#####Programmatic Customization
If you need to programmatically configure your embedded servlet container, you can register a Spring bean that implements the WebServerFactoryCustomizer interface. WebServerFactoryCustomizer provides access to the ConfigurableServletWebServerFactory, which includes numerous customization setter methods. The following example shows programmatically setting the port:

```java
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

	@Override
	public void customize(ConfigurableServletWebServerFactory server) {
		server.setPort(9000);
	}

}
```

[Note]
TomcatServletWebServerFactory, JettyServletWebServerFactory and UndertowServletWebServerFactory are dedicated variants of ConfigurableServletWebServerFactory that have additional customization setter methods for Tomcat, Jetty and Undertow respectively.

#####Customizing ConfigurableServletWebServerFactory Directly
If the preceding customization techniques are too limited, you can register the TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory bean yourself.

```java
@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
	TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
	factory.setPort(9000);
	factory.setSessionTimeout(10, TimeUnit.MINUTES);
	factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
	return factory;
}
```

Setters are provided for many configuration options. Several protected method “hooks” are also provided should you need to do something more exotic. See the source code documentation for details.

####29.4.5 JSP Limitations <U>(추후 사용예정....)</U>
When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.

* With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with java -jar, and will also be deployable to any standard container. JSPs are not supported when using an executable jar.
* Undertow does not support JSPs.
* Creating a custom error.jsp page does not override the default view for error handling. Custom error pages should be used instead.

There is a JSP sample so that you can see how to set things up.

####29.5 Embedded Reactive Server Support <U>(추후 사용예정....)</U>
Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty, and Undertow. Most developers use the appropriate “Starter” to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080.

####29.6 Reactive Server Resources Configuration <U>(추후 사용예정....)</U>
When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: ReactorResourceFactory or JettyResourceFactory.

By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given:

the same technology is used for server and client
the client instance is built using the WebClient.Builder bean auto-configured by Spring Boot
Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom ReactorResourceFactory or JettyResourceFactory bean - this will be applied to both clients and servers.

You can learn more about the resource configuration on the client side in the WebClient Runtime section.