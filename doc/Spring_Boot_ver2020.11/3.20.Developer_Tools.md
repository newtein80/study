####3.8. Developer Tools (제일 이해 안되는 부분!)

Spring Boot에는 응용 프로그램 개발 환경을 좀 더 쾌적하게 만들 수있는 추가 도구 세트가 포함되어 있습니다.
<small><small>Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant.</small></small>

`spring-boot-devtools` 모듈은 추가 개발 시간에 대한 이점을 제공하기 위해 모든 프로젝트에 포함될 수 있습니다.
<small><small>The `spring-boot-devtools` module can be included in any project to provide additional development-time features.</small></small>

devtools 지원을 포함하려면 빌드에 모듈 dependency을 추가하십시오 (Maven 및 Gradle의 다음 목록 참조).
<small><small>To include devtools support, add the module dependency to your build, as shown in the following listings for Maven and Gradle:</small></small>

* Maven. 
```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-devtools</artifactId>
		<optional>true</optional>
	</dependency>
</dependencies>
```

* Gradle. 
```json
configurations {
	developmentOnly
	runtimeClasspath {
		extendsFrom developmentOnly
	}
}
dependencies {
	developmentOnly("org.springframework.boot:spring-boot-devtools")
}
```

>:bulb:
완전히 패키지 된 응용 프로그램을 실행하면 개발자 도구가 자동으로 비활성화됩니다.
<small><small>Developer tools are automatically disabled when running a fully packaged application.</small></small>
응용 프로그램이 java -jar에서 실행되거나 특수 클래스 로더에서 시작된 경우 “production application”으로 간주됩니다.
<small><small>If your application is launched from `java -jar` or if it is started from a special classloader, then it is considered a “production application”.</small></small>
해당 사항이 적용되지 않는다면 (예 : 컨테이너에서 애플리케이션을 실행하는 경우) devtools를 제외하거나 `-Dspring.devtools.restart.enabled = false` 시스템 속성을 설정하십시오.
<small><small>If that does not apply to you (i.e. if you run your application from a container), consider excluding devtools or set the `-Dspring.devtools.restart.enabled=false` system property.</small></small>

>:bulb:
Maven에서 `spring-boot-devtools` 의 `optional` 속성을 사용하거나 Gradle에서 사용자 정의 `developmentOnly` 설정을 사용함으로써 (위 gradle 설정 참조) devtools이 프로젝트를 사용하는 다른 모듈에 일시적으로 적용되는 것을 방지하는 것이 가장 좋습니다.
<small><small>Flagging the dependency as optional in Maven or using a custom `developmentOnly` configuration in Gradle (as shown above) is a best practice that prevents devtools from being transitively applied to other modules that use your project.</small></small>

>:bulb:
re-package 된 아카이브는 기본적으로 devtools를 포함하지 않습니다.
<small><small>Repackaged archives do not contain devtools by default.</small></small>
[특정 원격 devtools 기능](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-remote)을 사용하려면 `excludeDevtools` 빌드 특성를 사용 불가능하게 설정하여 포함 시키십시오.
<small><small>If you want to use a [certain remote devtools feature](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-remote), you need to disable the `excludeDevtools` build property to include it.</small></small>
이 속성은 Maven과 Gradle 플러그인 모두에서 지원됩니다.
<small><small>The property is supported with both the Maven and Gradle plugins.</small></small>

####3.8.1 Property Defaults

Spring Boot가 지원하는 몇몇 라이브러리는 성능을 향상시키기 위해 캐시를 사용합니다.
<small><small>Several of the libraries supported by Spring Boot use caches to improve performance.</small></small>

예를 들어, [template engines](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-template-engines)은 컴파일 된 템플릿을 캐시하여 반복적으로 템플릿 파일을 구문 분석하지 않도록합니다.
<small><small>For example, [template engines](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-template-engines) cache compiled templates to avoid repeatedly parsing template files.</small></small>

또한 Spring MVC는 정적 리소스를 제공 할 때 HTTP 캐싱 헤더를 응답에 추가 할 수 있습니다.
<small><small>Also, Spring MVC can add HTTP caching headers to responses when serving static resources.</small></small>

캐싱은 프로덕션 환경에서 매우 유용하지만 개발 중에는 비생산적 일 수 있으므로 응용 프로그램에서 방금 변경 한 사항을 볼 수 없습니다.
<small><small>While caching is very beneficial in production, it can be counter-productive during development, preventing you from seeing the changes you just made in your application.</small></small>

따라서 `spring-boot-devtools`는 기본적으로 캐싱 옵션을 비활성화합니다.
<small><small>For this reason, `spring-boot-devtools` disables the caching options by default.</small></small>

캐시 옵션은 일반적으로 `application.properties` 파일의 설정으로 구성됩니다.
<small><small>Cache options are usually configured by settings in your `application.properties` file.</small></small>

예를 들어, Thymeleaf는 `spring.thymeleaf.cache` 속성을 제공합니다.
<small><small>For example, Thymeleaf offers the `spring.thymeleaf.cache` property.</small></small>

`spring-boot-devtools` 모듈은 이러한 속성을 수동으로 설정하지 않고 자동으로 현명한 개발 시간 구성<sup>:speech_balloon:</sup>을 적용합니다.
<small><small>Rather than needing to set these properties manually, the `spring-boot-devtools` module automatically applies sensible development-time<sup>:speech_balloon:</sup> configuration.</small></small>

>:speech_balloon: `spring-boot-devtools` 모듈은 이러한 속성을 수동으로 설정하기보다는 자동으로 설정하여 개발시간 구성(?)에 대한 유연성을 제공한다.

Spring MVC 및 Spring WebFlux applications을 개발할 때 웹 요청에 대한 추가 정보가 필요하기 때문에 개발자 도구는 `web` logging group에 `DEBUG` 로깅을 활성화합니다.
<small><small>Because you need more information about web requests while developing Spring MVC and Spring WebFlux applications, developer tools will enable `DEBUG` logging for the `web` logging group.</small></small>

이렇게하면 들어오는 요청, 처리기가 처리중인 요청, 응답 결과 등에 대한 정보를 얻을 수 있습니다.
<small><small>This will give you information about the incoming request, which handler is processing it, the response outcome, etc.</small></small>

잠재적으로 중요한 정보를 포함하여 모든 요청 세부 사항을 기록하려면 `spring.http.log-request-details` 구성 property를 사용 가능하게 설정할 수 있습니다.
<small><small>If you wish to log all request details (including potentially sensitive information), you can turn on the `spring.http.log-request-details` configuration property.</small></small>

>:bulb:
속성 기본값을 적용하지 않으려면 `application.properties`에서 `spring.devtools.add-properties`를 `false`로 설정할 수 있습니다.
<small><small>If you don’t want property defaults to be applied you can set `spring.devtools.add-properties` to `false` in your `application.properties`.</small></small>

>:bulb:
devtools에서 적용한 속성의 전체 목록은 [DevToolsPropertyDefaultsPostProcessor](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java)를 참조하십시오.
<small><small>For a complete list of the properties that are applied by the devtools, see [DevToolsPropertyDefaultsPostProcessor](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java).</small></small>

####3.8.2 Automatic Restart

`spring-boot-devtools`를 사용하는 응용 프로그램은 classpath의 파일이 변경 될 때마다 자동으로 다시 시작됩니다.
<small><small>Applications that use `spring-boot-devtools` automatically restart whenever files on the classpath change.</small></small>

이는 IDE에서 작업 할 때 코드 변경에 대한 매우 빠른 피드백 루프(feedback loop)를 제공하므로 유용한 기능입니다.
<small><small>This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes.</small></small>

기본적으로 폴더를 가리키는 classpath의 항목들의 변경 사항을 모니터링합니다.
<small><small>By default, any entry on the classpath that points to a folder is monitored for changes.</small></small>

static resources 및 view templates와 같은 특정 resources은 [응용 프로그램을 다시 시작할 필요가 없습니다](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-exclude).
<small><small>Note that certain resources, such as static assets and view templates, [do not need to restart the application](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-exclude).</small></small>

#####Triggering a restart
- DevTools는 classpath 리소스를 모니터링하기 때문에 restart에 트리거하는 유일한 방법은 클래스 경로를 업데이트하는 것입니다.
<small><small>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath.</small></small>
  - classpath를 업데이트하는 방법은 사용중인 IDE에 따라 다릅니다.
  <small><small>The way in which you cause the classpath to be updated depends on the IDE that you are using.</small></small>
  - Eclipse의 경우에는 수정 된 파일을 저장하면 classpath가 업데이트되고 다시 시작됩니다.
  <small><small>In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.</small></small>
  - IntelliJ IDEA의 경우에는 프로젝트 빌드 (`Build -> Build Project`)는 동일한 효과를냅니다.
  <small><small>In IntelliJ IDEA, building the project (Build -> Build Project) has the same effect.</small></small>

>:bulb:
빌드 플러그인을 사용하여 Maven 또는 Gradle로 다시 시작하는 경우 분기 설정을 활성화 된 상태로 두어야합니다.
<small><small>If you are restarting with Maven or Gradle using the build plugin you must leave the forking set to enabled.</small></small>
분기를 비활성화하면 devtools에서 사용하는 격리 된 응용 프로그램 클래스 로더가 생성되지 않고 다시 시작이 제대로 작동하지 않습니다.
<small><small>If you disable forking, the isolated application classloader used by devtools will not be created and restarts will not operate properly.</small></small>

>:bulb:
forking이 활성화되어있는 한, DevTools는 제대로 작동하기 위해선 격리 된 application classloader가 필요하기 때문에 지원되는 빌드 플러그인 (Maven 및 Gradle)을 사용하여 응용 프로그램을 시작할 수도 있습니다.
<small><small>As long as forking is enabled, you can also start your application by using the supported build plugins (Maven and Gradle), since DevTools needs an isolated application classloader to operate properly.</small></small>
기본적으로 Gradle과 Maven은 classpath에서 DevTools를 감지 할 때 이를 수행합니다.
<small><small>By default, Gradle and Maven do that when they detect DevTools on the classpath.</small></small>

>:bulb:
LiveReload와 함께 사용하면 자동 다시 시작이 잘 작동합니다.
<small><small>Automatic restart works very well when used with LiveReload.</small></small>
자세한 내용은 [LiveReload section](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-livereload)을 참조하십시오.
<small><small>See the [LiveReload section](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-livereload) for details.</small></small>
JRebel을 사용하는 경우, 자동 재시작은 동적 클래스 재로드를 위해 비활성화됩니다.
<small><small>If you use JRebel, automatic restarts are disabled in favor of dynamic class reloading.</small></small>
다른 devtools 기능 (예 : LiveReload 및 속성 재정의)은 계속 사용할 수 있습니다.
<small><small>Other devtools features (such as LiveReload and property overrides) can still be used.</small></small>

>:bulb:
DevTools는 application 컨텍스트의 `shutdown hook`을 사용하여 다시 시작하는 동안 닫습니다.
<small><small>DevTools relies on the application context’s `shutdown hook` to close it during a restart.</small></small>
`shutdown hook` `(SpringApplication.setRegisterShutdownHook (false))`을 비활성화 한 경우 올바르게 작동하지 않습니다.
<small><small>It does not work correctly if you have disabled the `shutdown hook` (SpringApplication.setRegisterShutdownHook(false)).</small></small>
:clipboard: **shutdown hook : ?????????? [참고링크](https://javacan.tistory.com/entry/86)**

>:bulb:
classpath에있는 항목이 변경 될 때 다시 시작해야하는지 결정할 때 DevTools는 `spring-boot`, `spring-boot-devtools`, `spring-boot-autoconfigure`, `spring-boot-actuator` 및 `spring-boot-starter`라는 프로젝트를 자동으로 무시합니다.
<small><small>When deciding if an entry on the classpath should trigger a restart when it changes, DevTools automatically ignores projects named `spring-boot`, `spring-boot-devtools`, `spring-boot-autoconfigure`, `spring-boot-actuator` and `spring-boot-starter`.</small></small>

>:bulb:
DevTools는 `ApplicationContext`에서 사용하는 `ResourceLoader`를 사용자 정의해야합니다.
<small><small>DevTools needs to customize the `ResourceLoader` used by the `ApplicationContext`.</small></small>
응용 프로그램에서 이미 제공하는 경우에는 래핑됩니다.
<small><small>If your application provides one already, it is going to be wrapped.</small></small>
`ApplicationContext`에 대한 `getResource` 메소드의 직접 재정의는 지원되지 않습니다.
<small><small>Direct override of the `getResource` method on the `ApplicationContext` is not supported.</small></small>

#####Restart vs Reload
* Spring Boot가 제공하는 restart 기술은 두 개의 classloaders를 사용하여 작동합니다.
<small><small>The restart technology provided by Spring Boot works by using two classloaders.</small></small>
변경되지 않는 Classes (예 : third-party jars의 클래스)는 ***기본*** classloader에 로드됩니다.
<small><small>Classes that do not change (for example, those from third-party jars) are loaded into a ***base*** classloader.</small></small>
개발 중인 클래스는 ***restart*** classloader에 로드됩니다.
<small><small>Classes that you are actively developing are loaded into a ***restart*** classloader.</small></small>
응용 프로그램이 다시 시작되면 ***restart*** classloader가 버려지고 새 것이 생성됩니다.
<small><small>When the application is restarted, the ***restart*** classloader is thrown away and a new one is created.</small></small>
이 방법은 ***기본*** classloader가 이미 사용 가능하고 채워지기 때문에 일반적으로 응용 프로그램 재시작이 “cold starts”보다 훨씬 빠르다는 것을 의미합니다.
<small><small>This approach means that application restarts are typically much faster than “cold starts”, since the ***base*** classloader is already available and populated.</small></small>

* 재시작이 애플리케이션에 충분히 빠르지 않거나 클래스 로딩 문제가 발생하는 경우 ZeroTurnaround에서 JRebel과 같은 기술을 다시 로드하는 것을 고려할 수 있습니다.
<small><small>If you find that restarts are not quick enough for your applications or you encounter classloading issues, you could consider reloading technologies such as JRebel from ZeroTurnaround.</small></small>
클래스가 로드 될 때 클래스를 다시 작성하여 다시 로드하기 쉽도록 합니다.
<small><small>These work by rewriting classes as they are loaded to make them more amenable to reloading.</small></small>

#####Logging changes in condition evaluation

<small><small>By default, each time your application restarts, a report showing the condition evaluation delta is logged.</small></small>
기본적으로 응용 프로그램이 다시 시작될 때마다 조건 평가 델타(the condition evaluation delta)를 나타내는 보고서가 기록됩니다.
<small><small>The report shows the changes to your application’s auto-configuration as you make changes such as adding or removing beans and setting configuration properties.</small></small>
보고서는 bean 추가 또는 제거 및 configuration 설정과 같은 변경을 수행 할 때 application의 auto-configuration에 대한 변경 사항을 표시합니다.

> [소스 블럭 지원 언어](http://haroopress.com/post/fenced-code-block/)

<small><small>To disable the logging of the report, set the following property:</small></small>
보고서 로깅을 사용하지 않으려면 다음 property를 설정하십시오.
```bash
spring.devtools.restart.log-condition-evaluation-delta=false
```
######Excluding Resources
<small><small>Certain resources do not necessarily need to trigger a restart when they are changed.</small></small>
특정 resources는 변경 될 때 다시 시작을 트리거하지 않아도됩니다.
<small><small>For example, Thymeleaf templates can be edited in-place. By default, changing resources in `/META-INF/maven`, `/META-INF/resources`, `/resources`, `/static`, `/public`, or `/templates` does not trigger a restart but does trigger a [live reload](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-livereload).</small></small>
예를 들어, Thymeleaf 템플릿을 제자리에서 편집 할 수 있습니다. 기본적으로 `/ META-INF / maven`, `/ META-INF / resources`, `/ resources`, `/ static`, `/ public` 또는 `/ templates`의 resources을 변경하면 재시작이 트리거되지 않지만 [실제 재로드](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-livereload)가 트리거됩니다.
<small><small>If you want to customize these exclusions, you can use the `spring.devtools.restart.exclude` property.</small></small>
이러한 제외 항목을 사용자 정의하려면 `spring.devtools.restart.exclude` property를 사용할 수 있습니다.
<small><small>For example, to exclude only `/static` and `/public` you would set the following property:</small></small>
예를 들어, `/ static` 및 `/ public` 만 제외하려면 다음 property를 설정하십시오.
```ini
spring.devtools.restart.exclude=static/**,public/**
```
>:bulb:
<small><small>If you want to keep those defaults and add additional exclusions, use the `spring.devtools.restart.additional-exclude` property instead.</small></small>
이러한 기본값을 유지하고 제외를 추가하려면 `spring.devtools.restart.additional-exclude` property를 대신 사용하십시오.

######Watching Additional Paths
<small><small>You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath.</small></small>
classpath에 없는 파일을 변경할 때 application을 다시 시작하거나 다시 로드해야 할 수 있습니다.
<small><small>To do so, use the `spring.devtools.restart.additional-paths` property to configure additional paths to watch for changes.</small></small>
그렇게 하려면 `spring.devtools.restart.additional-paths` property을 사용하여 추가 경로를 구성하여 변경 사항을 감시하십시오.
<small><small>You can use the `spring.devtools.restart.exclude` property [described earlier](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-exclude) to control whether changes beneath the additional paths trigger a full restart or a live reload.</small></small>
[앞에서 설명한](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-exclude) `spring.devtools.restart.exclude` 속성을 사용하여 추가 경로 아래의 변경 사항이 전체 다시 시작 또는 실제 다시 로드를 트리거하는지 여부를 제어 할 수 있습니다.

######Disabling Restart
<small><small>If you do not want to use the restart feature, you can disable it by using the `spring.devtools.restart.enabled` property.</small></small>
다시 시작 기능을 사용하지 않으려면 `spring.devtools.restart.enabled` 속성을 사용하여 비활성화 할 수 있습니다.
<small><small>In most cases, you can set this property in your `application.properties` (doing so still initializes the restart classloader, but it does not watch for file changes).</small></small>
대부분의 경우 `application.properties`에서 이 속성을 설정할 수 있습니다 (이렇게 해도 restart classloader가 초기화되지만 파일 변경을 감시하지는 않습니다).

<small><small>If you need to completely disable restart support (for example, because it does not work with a specific library), you need to set the `spring.devtools.restart.enabled` `System` property to `false` before calling `SpringApplication.run(…​)`, as shown in the following example:</small></small>
restart을 완전히 비활성화해야하는 경우 (예 : 특정 라이브러리에서 작동하지 않기 때문에) `SpringApplication.run (...)`을 호출하기 전에 `spring.devtools.restart.enabled` `시스템` 속성을 `false`로 설정해야합니다. 다음 예제에 나와 있습니다.

```java
public static void main(String[] args) {
	System.setProperty("spring.devtools.restart.enabled", "false");
	SpringApplication.run(MyApp.class, args);
}
```
######Using a Trigger File
<small><small>If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times.</small></small>
변경된 파일을 지속적으로 컴파일하는 IDE로 작업하는 경우 특정 시간에만 다시 시작하는 것이 좋습니다.
<small><small>To do so, you can use a “trigger file”, which is a special file that must be modified when you want to actually trigger a restart check.</small></small>
이렇게하려면 “trigger file”을 사용할 수 있습니다. 이 파일은 실제로 restart 검사를 트리거 할 때 수정해야 하는 특수 파일입니다.

>:bulb:
<small><small>Any update to the file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.</small></small>
파일에 대한 모든 업데이트는 검사를 트리거하지만 실제로 재시작은 Devtools가 할 일이 있음을 감지 한 경우에만 발생합니다.

<small><small>To use a “trigger file”, set the `spring.devtools.restart.trigger-file` property to the path of your trigger file.</small></small>
“trigger file”을 사용하려면 `spring.devtools.restart.trigger-file` 속성을 트리거 파일의 경로로 설정하십시오.
<small><small>The trigger file must appear somewhere on your classpath.</small></small>
트리거 파일은 클래스 경로의 어딘가에 나타나야합니다.

<small><small>For example, if you have a project with the following structure:</small></small>
예를 들어 다음과 같은 구조의 프로젝트가있는 경우 :
```
src
+- main
   +- resources
      +- .reloadtrigger
```

<small><small>Then your trigger-file property would be:</small></small>
그러면 트리거 파일 속성은 다음과 같습니다.

```ini
spring.devtools.restart.trigger-file=.reloadtrigger
```

>:bulb:
<small><small>You might want to set `spring.devtools.restart.trigger-file` as a [global setting](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-globalsettings), so that all your projects behave in the same way.</small></small>
모든 프로젝트가 동일한 방식으로 동작하도록 `spring.devtools.restart.trigger-file`을 [전역 설정](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-globalsettings)으로 설정할 수 있습니다.

<small><small>Some IDEs have features that save you from needing to update your trigger file manually.</small></small>
일부 IDE에는 트리거 파일을 수동으로 업데이트 할 필요가없는 기능이 있습니다.
<small><small>[Spring Tools for Eclipse](https://spring.io/tools) and IntelliJ IDEA (Ultimate Edition) both have such support.</small></small>
[Eclipse 용 Spring Tools](https://spring.io/tools)와 IntelliJ IDEA (Ultimate Edition) 모두 이러한 지원을 제공합니다.
<small><small>With Spring Tools, you can use the “reload” button from the console view (as long as your trigger-file is named .reloadtrigger).</small></small>
Spring Tools를 사용하면 콘솔보기에서 "reload"버튼을 사용할 수 있습니다 (트리거 파일 이름이 .reloadtrigger 인 경우).
<small><small>For IntelliJ IDEA, you can follow the instructions in their documentation.</small></small>
IntelliJ IDEA의 경우 설명서의 지침을 따를 수 있습니다.

######Customizing the Restart Classloader
<small><small>As described earlier in the [Restart vs Reload](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-spring-boot-restart-vs-reload) section, restart functionality is implemented by using two classloaders.</small></small>
[Restart vs Reload](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-spring-boot-restart-vs-reload) 섹션에서 설명한 것처럼 restart 기능은 두 개의 classloaders를 사용하여 구현됩니다.
<small><small>For most applications, this approach works well. However, it can sometimes cause classloading issues.</small></small>
대부분의 응용 프로그램에서이 잘 동작하지만 가끔 클래스 로딩 문제가 발생할 수 있습니다.

<small><small>By default, any open project in your IDE is loaded with the “restart” classloader, and any regular `.jar` file is loaded with the “base” classloader.</small></small>
기본적으로 IDE의 열려있는 프로젝트에는 “restart” classloader가 로드되고 일반 `.jar` 파일에는 “base” classloader가 로드됩니다.
<small><small>If you work on a multi-module project, and not every module is imported into your IDE, you may need to customize things.</small></small>
다중 모듈 프로젝트에서 작업하고 모든 모듈을 IDE로 가져 오지 않은 경우 사용자 정의해야 할 수도 있습니다.
<small><small>To do so, you can create a `META-INF/spring-devtools.properties` file.</small></small>
이렇게하려면 `META-INF / spring-devtools.properties` 파일을 만들 수 있습니다.

<small><small>The `spring-devtools.properties` file can contain properties prefixed with `restart.exclude` and `restart.include`.</small></small>
`spring-devtools.properties` 파일은 `restart.exclude`와 `restart.include`로 시작되는 속성을 포함 할 수 있습니다.
<small><small>The `include` elements are items that should be pulled up into the “restart” classloader, and the exclude elements are items that should be pushed down into the “base” classloader.</small></small>
`include` 요소는 “restart” classloader로 끌어 올려야하는 항목이며 exclude 요소는 “base” classloader로 푸시 다운되어야하는 항목입니다.
<small><small>The value of the property is a regex pattern that is applied to the classpath, as shown in the following example:</small></small>
이 프로퍼티의 값은 다음 예제와 같이 classpath에 적용되는 정규식 패턴입니다.
```ini
restart.exclude.companycommonlibs=/mycorp-common-[\\w\\d-\.]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w\\d-\.]+\.jar
```
>:bulb:
<small><small>All property keys must be unique.</small></small>
모든 속성 키는 고유해야합니다.
<small><small>As long as a property starts with `restart.include.` or `restart.exclude.` it is considered.</small></small>
속성이 `restart.include.` 또는 `restart.exclude.`로 시작되는 앞서 설명한 것과 같은 속성으로 고려됩니다.

>:bulb:
<small><small>All META-INF/spring-devtools.properties from the classpath are loaded.</small></small>
`classpath`의 모든 `META-INF / spring-devtools.properties`가 로드됩니다.
<small><small>You can package files inside your project, or in the libraries that the project consumes.</small></small>
프로젝트 또는 프로젝트가 사용하는 라이브러리에서 파일을 패키지화 할 수 있습니다.

######Known Limitations
<small><small>Restart functionality does not work well with objects that are deserialized by using a standard `ObjectInputStream`.</small></small>
Restart 기능이 표준 `ObjectInputStream`을 사용하여 직렬화 복원 된 오브젝트와 제대로 작동하지 않습니다.
<small><small>If you need to deserialize data, you may need to use Spring’s `ConfigurableObjectInputStream` in combination with `Thread.currentThread().getContextClassLoader()`.</small></small>
데이터를 비-직렬화(deserialize)해야하는 경우 Spring의 `ConfigurableObjectInputStream`을 `Thread.currentThread().getContextClassLoader()` 와 함께 사용해야 할 수도 있습니다.

<small><small>Unfortunately, several third-party libraries deserialize without considering the context classloader.</small></small>
불행히도 몇몇 third-party libraries는 context classloader를 고려하지 않고 deserialize합니다.
<small><small>If you find such a problem, you need to request a fix with the original authors.</small></small>
이러한 문제가 발생하면 원래 작성자에게 수정을 요청해야합니다.

####3.8.3 LiveReload
<small><small>The `spring-boot-devtools` module includes an embedded LiveReload server that can be used to trigger a browser refresh when a resource is changed.</small></small>
`spring-boot-devtools` 모듈에는 리소스가 변경 될 때 브라우저 새로 고침을 트리거하는 데 사용 할 수있는 내장 된 LiveReload 서버가 포함되어 있습니다.
<small><small>LiveReload browser extensions are freely available for Chrome, Firefox and Safari from [livereload.com](http://livereload.com/extensions/).</small></small>
LiveReload 브라우저 확장은 [livereload.com](http://livereload.com/extensions/)에서 Chrome, Firefox 및 Safari 용으로 자유롭게 사용할 수 있습니다.

<small><small>If you do not want to start the LiveReload server when your application runs, you can set the `spring.devtools.livereload.enabled` property to `false`.</small></small>
응용 프로그램이 실행될 때 LiveReload 서버를 시작하지 않으려면 `spring.devtools.livereload.enabled` 속성을 `false`로 설정 할 수 있습니다.

>:bulb:
<small><small>You can only run one LiveReload server at a time.</small></small>
한 번에 하나의 LiveReload 서버 만 실행할 수 있습니다.
<small><small>Before starting your application, ensure that no other LiveReload servers are running.</small></small>
응용 프로그램을 시작하기 전에 다른 LiveReload 서버가 실행되고 있지 않은지 확인하십시오.
<small><small>If you start multiple applications from your IDE, only the first has LiveReload support.</small></small>
IDE에서 여러 응용 프로그램을 시작하면 첫 번째 응용 프로그램 만 LiveReload를 지원합니다.

>:bulb:
<small><small>To trigger LiveReload when a file changes, [Automatic Restart](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-restart) must be enabled.</small></small>
파일이 변경 될 때 LiveReload를 트리거하려면 [Automatic Restart](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-restart)을 활성화해야합니다.

####3.8.4 Global Settings
<small><small>You can configure global devtools settings by adding a file named `.spring-boot-devtools.properties` to your `$HOME` folder **(note that the filename starts with “.”)**.</small></small>
`$ HOME `폴더에 `.spring-boot-devtools.properties` 파일을 추가하여 전역 devtools 설정을 구성 할 수 있습니다 **(파일 이름은 "."로 시작합니다)**.

<small><small>You can configure global devtools settings by adding any of the following files to the `$HOME/.config/spring-boot` directory:</small></small>
`$ HOME / .config / spring-boot` 디렉토리에 다음 파일 중 하나를 추가하여 전역 devtools 설정을 구성 할 수 있습니다.

1. spring-boot-devtools.properties
2. spring-boot-devtools.yaml
3. spring-boot-devtools.yml

<small><small>Any properties added to this file apply to **all** Spring Boot applications on your machine that use devtools.</small></small>
이 파일에 추가 된 모든 속성은 devtools를 사용하는 시스템의 **모든** Spring Boot applications에 적용됩니다.
<small><small>For example, to configure restart to always use a [trigger file](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-triggerfile), you would add the following property:</small></small>
예를 들어 항상 [trigger file](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart-triggerfile)을 사용하도록 restart를 구성하려면 다음 등록 정보를 추가합니다.

######~/.spring-boot-devtools.properties. 
```ini
spring.devtools.reload.trigger-file=.reloadtrigger
```
>:bulb:
<small><small>If devtools configuration files are not found in `$HOME/.config/spring-boot`, the root of the `$HOME` directory is searched for the presence of a `.spring-boot-devtools.properties` file.</small></small>
devtools 설정 파일이`$ HOME / .config / spring-boot`에 없으면`$ HOME` 디렉토리의 루트에서`.spring-boot-devtools.properties` 파일이 있는지 검색합니다.
<small><small>This allows you to share the devtools global configuration with applications that are on an older version of Spring Boot that does not support the `$HOME/.config/spring-boot` location.</small></small>
이렇게하면`$ HOME / .config / spring-boot` 위치를 지원하지 않는 이전 버전의 Spring Boot에있는 애플리케이션과 devtools 전역 구성을 공유 할 수 있습니다.

>:bulb:
<small><small>Profiles activated in `.spring-boot-devtools.properties` will not affect the loading of profile-specific configuration files.</small></small>
`.spring-boot-devtools.properties`에서 활성화 된 프로필은 프로필 별 구성 파일로드에 영향을 미치지 않습니다.
<small><small>Profiles are not supported in devtools properties/yaml files.</small></small>
프로필은 devtools 속성 / yaml 파일에서 지원되지 않습니다.
<small><small>Any profiles activated in `.spring-boot-devtools.properties` will not affect the loading of [profile-specific configuration files](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-files-profile-specific).</small></small>
`.spring-boot-devtools.properties`에서 활성화 된 모든 프로필은 [프로필 별 구성 파일](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-files-profile-specific)의로드에 영향을주지 않습니다.
<small><small>Profile specific filenames (of the form `spring-boot-devtools-<profile>.properties`) and `spring.config.activate.on-profile` documents in both YAML and Properties files are not supported.</small></small>
프로필 특정 파일 이름 (`spring-boot-devtools- <profile> .properties` 형식) 및`spring.config.activate.on-profile` 문서는 YAML 및 속성 파일 모두에서 지원되지 않습니다.

######Configuring File System Watcher
<small><small>[FileSystemWatcher](https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.java) works by polling the class changes with a certain time interval, and then waiting for a predefined quiet period to make sure there are no more changes.</small></small>
[FileSystemWatcher](https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.java)는 특정 시간 간격으로 클래스 변경 사항을 폴링 한 다음 더 이상 변경 사항이 없는지 확인하기 위해 미리 정의 된 조용한 기간을 기다리는 방식으로 작동합니다.
<small><small>Since Spring Boot relies entirely on the IDE to compile and copy files into the location from where Spring Boot can read them, you might find that there are times when certain changes are not reflected when devtools restarts the application.</small></small>
Spring Boot는 전적으로 IDE에 의존하여 Spring Boot가 읽을 수있는 위치로 파일을 컴파일하고 복사하므로 devtools가 애플리케이션을 다시 시작할 때 특정 변경 사항이 반영되지 않는 경우가있을 수 있습니다.
<small><small>If you observe such problems constantly, try increasing the `spring.devtools.restart.poll-interval` and `spring.devtools.restart.quiet-period` parameters to the values that fit your development environment:</small></small>
이러한 문제가 지속적으로 관찰되는 경우`spring.devtools.restart.poll-interval` 및`spring.devtools.restart.quiet-period` 매개 변수를 개발 환경에 맞는 값으로 늘려보십시오.

```ini
spring.devtools.restart.poll-interval=2s
spring.devtools.restart.quiet-period=1s
```
<small><small>The monitored classpath directories are now polled every 2 seconds for changes, and a 1 second quiet period is maintained to make sure there are no additional class changes.</small></small>
모니터링되는 클래스 경로 디렉토리는 이제 변경 사항에 대해 2 초마다 폴링되며 추가 클래스 변경 사항이 없는지 확인하기 위해 1 초의 조용한 기간이 유지됩니다.

####3.8.5 Remote Applications (나중에 볼 것!)

- old version
<small><small>The Spring Boot developer tools are not limited to local development.</small></small>
Spring Boot 개발자 도구는 로컬 개발에만 국한되지 않습니다.
<small><small>You can also use several features when running applications remotely.</small></small>
응용 프로그램을 원격으로 실행할 때 여러 기능을 사용할 수도 있습니다.
<small><small>Remote support is opt-in.</small></small>
원격 지원이 옵트 인됩니다.
<small><small>To enable it, you need to make sure that devtools is included in the repackaged archive, as shown in the following listing:</small></small>
이를 활성화하려면 다음 목록에 표시된 것처럼 devtools가 리 패키징 된 아카이브에 포함되어 있는지 확인해야합니다.

<small><small>The Spring Boot developer tools are not limited to local development.</small></small>
Spring Boot 개발자 도구는 로컬 개발에만 국한되지 않습니다.
<small><small>You can also use several features when running applications remotely.</small></small>
응용 프로그램을 원격으로 실행할 때 여러 기능을 사용할 수도 있습니다.
<small><small>Remote support is opt-in as enabling it can be a security risk.</small></small>
원격 지원은 보안 위험이 될 수 있으므로 옵트 인됩니다.
<small><small>It should only be enabled when running on a trusted network or when secured with SSL.</small></small>
신뢰할 수있는 네트워크에서 실행 중이거나 SSL로 보안 된 경우에만 활성화해야합니다.
<small><small>If neither of these options is available to you, you should not use DevTools' remote support.</small></small>
이러한 옵션 중 어느 것도 사용할 수없는 경우 DevTools의 원격 지원을 사용해서는 안됩니다.
<small><small>You should never enable support on a production deployment.</small></small>
프로덕션 배포에 대한 지원을 활성화해서는 안됩니다.

<small><small>To enable it, you need to make sure that devtools is included in the repackaged archive, as shown in the following listing:</small></small>
이를 활성화하려면 다음 목록에 표시된 것처럼 devtools가 리 패키징 된 아카이브에 포함되어 있는지 확인해야합니다.

```xml
<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
			<configuration>
				<excludeDevtools>false</excludeDevtools>
			</configuration>
		</plugin>
	</plugins>
</build>
```
- old version
Then you need to set a spring.devtools.remote.secret property, as shown in the following example:
spring.devtools.remote.secret=mysecret
[Warning]
Enabling spring-boot-devtools on a remote application is a security risk. You should never enable support on a production deployment.
Remote devtools support is provided in two parts: a server-side endpoint that accepts connections and a client application that you run in your IDE. The server component is automatically enabled when the spring.devtools.remote.secret property is set. The client component must be launched manually.

Then you need to set the spring.devtools.remote.secret property. Like any important password or secret, the value should be unique and strong such that it cannot be guessed or brute-forced.

Remote devtools support is provided in two parts: a server-side endpoint that accepts connections and a client application that you run in your IDE. The server component is automatically enabled when the spring.devtools.remote.secret property is set. The client component must be launched manually.

######Running the Remote Client Application
The remote client application is designed to be run from within your IDE. You need to run org.springframework.boot.devtools.RemoteSpringApplication with the same classpath as the remote project that you connect to. The application’s single required argument is the remote URL to which it connects.

For example, if you are using Eclipse or STS and you have a project named my-app that you have deployed to Cloud Foundry, you would do the following:

* Select Run Configurations…​ from the Run menu.
* Create a new Java Application “launch configuration”.
* Browse for the my-app project.
* Use org.springframework.boot.devtools.RemoteSpringApplication as the main class.
* Add https://myapp.cfapps.io to the Program arguments (or whatever your remote URL is).
A running remote client might resemble the following listing:
```
  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.1.6.RELEASE

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
```
[Note]
Because the remote client is using the same classpath as the real application it can directly read application properties. This is how the spring.devtools.remote.secret property is read and passed to the server for authentication.

[Tip]
It is always advisable to use https:// as the connection protocol, so that traffic is encrypted and passwords cannot be intercepted.

[Tip]
If you need to use a proxy to access the remote application, configure the spring.devtools.remote.proxy.host and spring.devtools.remote.proxy.port properties.

######Remote Update
- old version
The remote client monitors your application classpath for changes in the same way as the local restart. Any updated resource is pushed to the remote application and (if required) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle.

The remote client monitors your application classpath for changes in the same way as the local restart. Any updated resource is pushed to the remote application and (if required) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle.

On a slower development environment, it may happen that the quiet period is not enough, and the changes in the classes may be split into batches. The server is restarted after the first batch of class changes is uploaded. The next batch can’t be sent to the application, since the server is restarting.

This is typically manifested by a warning in the RemoteSpringApplication logs about failing to upload some of the classes, and a consequent retry. But it may also lead to application code inconsistency and failure to restart after the first batch of changes is uploaded. If you observe such problems constantly, try increasing the spring.devtools.restart.poll-interval and spring.devtools.restart.quiet-period parameters to the values that fit your development environment. See the Configuring File System Watcher section for configuring these properties.

[Note]
Files are only monitored when the remote client is running. If you change a file before starting the remote client, it is not pushed to the remote server.

####3.9. Packaging Your Application for Production
<small><small>Executable jars can be used for production deployment.</small></small>
실행 가능한 jar는 프로덕션 배포에 사용할 수 있습니다.
<small><small>As they are self-contained, they are also ideally suited for cloud-based deployment.</small></small>
독립형이므로 클라우드 기반 배포에도 적합합니다.

<small><small>For additional “production ready” features, such as health, auditing, and metric REST or JMX end-points, consider adding `spring-boot-actuator`.</small></small>
상태, 감사 및 메트릭 REST 또는 JMX 엔드 포인트와 같은 추가 "생산 준비"기능의 경우 `spring-boot-actuator`를 추가하는 것이 좋습니다.
<small><small>See [Spring Boot Actuator: Production-ready Features](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) for details.</small></small>
자세한 내용은 [Spring Boot Actuator : 프로덕션 준비 기능](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready)을 참조하세요.

####3.10. What to Read Next
<small><small>You should now understand how you can use Spring Boot and some best practices that you should follow.</small></small>
이제 Spring Boot를 사용하는 방법과 따라야 할 몇 가지 모범 사례를 이해해야합니다.
<small><small>You can now go on to learn about specific [Spring Boot features](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features) in depth, or you could skip ahead and read about the [“production ready”](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) aspects of Spring Boot.</small></small>
이제 특정 Spring Boot 기능에 대해 자세히 알아 보거나 건너 뛰어 Spring Boot의 ["프로덕션 준비"](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready)측면에 대해 읽을 수 있습니다.