####24. Externalized Configuration
Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments.
Spring Boot를 사용하면 구성을 외부화하여 다른 환경에서 동일한 응용 프로그램 코드로 작업 할 수 있습니다.

You can use properties files, YAML files, environment variables, and command-line arguments to externalize configuration.
properties 파일, YAML 파일, environment variables 및 command-line arguments를 사용하여 구성을 외부화 할 수 있습니다.

Property values can be injected directly into your beans by using the `@Value` annotation, accessed through Spring’s Environment abstraction, or be [bound to structured objects](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties) through `@ConfigurationProperties`.
Property 값은 `@Value` annotation을 사용하여 Bean에 직접 삽입하거나 Spring의 환경 추상화(Spring’s Environment abstraction)를 통해 액세스하거나 `@ConfigurationProperties`를 통해 [구조화 된 객체에 바인딩](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties) 할 수 있습니다.

Spring Boot uses a very particular `PropertySource` order that is designed to allow sensible overriding of values.
스프링 부트 (Spring Boot)는 현명하게 값을 오버라이드를 허용하도록 설계된 매우 특별한 `PropertySource` 순서를 사용합니다.

Properties are considered in the following order:
등록 정보는 다음 순서로 고려됩니다.

1. [Devtools global settings properties](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings) on your home directory (~/.spring-boot-devtools.properties when devtools is active).
홈 디렉토리의 [devtools 전역 설정 등록 정보](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings) (devtools가 활성화 된 경우 `~ / .spring-boot-devtools.properties`)
2. [@TestPropertySource](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html) annotations on your tests.
tests 의 [@TestPropertySource](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html)  annotations.
3. `properties` attribute on your tests. Available on [@SpringBootTest](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html) and the [test annotations for testing a particular slice of your application](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests).
tests 의 `properties` 속성. [@SpringBootTest](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html) 및 [응용 프로그램의 특정 조각을 테스트하기위한 테스트 annotations](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests)에서 사용할 수 있습니다.
4. Command line arguments.
Command line arguments.
5. Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment variable or system property).
`SPRING_APPLICATION_JSON`의 Properties (환경 변수 또는 시스템 속성에 포함 된 inline JSON).
6. `ServletConfig` init parameters.
`ServletConfig` 초기화 매개 변수.
7. `ServletContext` init parameters.
`ServletContext`의 초기화 파라미터.
8. JNDI attributes from `java:comp/env`.
`java : comp / env`의 JNDI 속성.
9. Java System properties (`System.getProperties()`).
Java System 등록 정보 (`System.getProperties ()`).
10. OS environment variables.
OS 환경 변수.
11. A `RandomValuePropertySource` that has properties only in `random.*`.
속성이 `random.*` 만있는 `RandomValuePropertySource`입니다.
12. [Profile-specific application properties](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) outside of your packaged jar (`application-{profile}.properties` and YAML variants).
packaged jar 외부의 [프로필 별 응용 프로그램 속성](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) (`application- {profile} .properties` 및 YAML 변형).
13. [Profile-specific application properties](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) packaged inside your jar (`application-{profile}.properties` and YAML variants).
jar 파일 안에 패키징 된 [프로필 별 애플리케이션 속성](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties) (`application- {profile} .properties` 및 YAML 변형).
14. Application properties outside of your packaged jar (`application.properties` and YAML variants).
packaged jar (`application.properties` 및 YAML 변형) 외부의 응용 프로그램 속성.
15. Application properties packaged inside your jar (`application.properties` and YAML variants).
jar 안에 패키지 된 응용 프로그램 속성 (`application.properties` 및 YAML 변형).
16. [@PropertySource](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html) annotations on your @`Configuration` classes.
`@Configuration` 클래스의 [@PropertySource](https://docs.spring.io/spring/docs/5.1.8.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html) annotations.
17. Default properties (specified by setting `SpringApplication.setDefaultProperties`).
기본 속성 (`SpringApplication.setDefaultProperties`를 설정하여 지정).

To provide a concrete example, suppose you develop a `@Component` that uses a `name` property, as shown in the following example:
구체적인 예제를 제공하기 위해 다음 예제와 같이 `name` 속성을 사용하는 `@Component`를 개발한다고 가정합니다.

```java
import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}
```

On your application classpath (for example, inside your jar) you can have an `application.properties` file that provides a sensible default property value for `name`.
응용 프로그램 classpath (예 : jar 파일 내부)에서 `name`에 적합한 기본 등록 정보 값을 제공하는 `application.properties` 파일을 가질 수 있습니다.

When running in a new environment, an `application.properties` file can be provided outside of your jar that overrides the `name`.
새로운 환경에서 실행될 때 `application.properties` 파일을 jar 파일 외부에 제공하여 `name` 속성을 덮어 쓸 수 있습니다.

For one-off testing, you can launch with a specific command line switch (for example, java -jar app.jar --name="Spring").
일회성 테스트의 경우 특정 명령 줄 스위치(command line switch) (예 : `java -jar app.jar --name = "Spring"`)로 시작 할 수 있습니다.

>:bulb:
The `SPRING_APPLICATION_JSON` properties can be supplied on the command line with an environment variable.
명령 행에서 `SPRING_APPLICATION_JSON` 특성을 환경 변수와 함께 제공 할 수 있습니다.
For example, you could use the following line in a UN*X shell:
예를 들어 UN * X 쉘에서 다음 행을 사용할 수 있습니다.

> $ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
In the preceding example, you end up with acme.name=test in the Spring `Environment`.
앞의 예제에서는 Spring `환경`에서 `acme.name = test`로 끝난다.
You can also supply the JSON as `spring.application.json` in a System property, as shown in the following example:
다음 예제와 같이 JSON을 `Spring.application.json`으로 System 속성에 제공 할 수도 있습니다.

> $ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
You can also supply the JSON by using a command line argument, as shown in the following example:
다음 예제와 같이 command line argument를 사용하여 JSON을 제공 할 수도 있습니다.

> $ java -jar myapp.jar --spring.application.json='{"name":"test"}'
You can also supply the JSON as a JNDI variable, as follows: `java:comp/env/spring.application.json`.
다음과 같이 JSON을 JNDI 변수로 제공 할 수도 있습니다. `java : comp / env / spring.application.json`.

####24.1 Configuring Random Values
The `RandomValuePropertySource` is useful for injecting random values (for example, into secrets or test cases). It can produce integers, longs, uuids, or strings, as shown in the following example:
`RandomValuePropertySource`는 무작위 값 (예 : secrets 또는 test cases)을 주입하는 데 유용합니다. 다음 예제와 같이 integers, long, uuids 또는 strings을 생성 할 수 있습니다.

```ini
my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}
```

The `random.int*` syntax is `OPEN value (,max) CLOSE` where the OPEN,CLOSE are any character and `value,max` are integers.
`random.int*` 구문은 `OPEN value (, max) CLOSE`입니다. 여기서 OPEN, CLOSE는 character 이며, `value, max`는 정수입니다.
If max is provided, then value is the minimum value and max is the maximum value (exclusive).
max가 제공되면 value는 최소값이고 max는 최대 값입니다 (배타적입니다).


####24.2 Accessing Command Line Properties
By default, SpringApplication converts any command line option arguments (that is, arguments starting with `--`, such as `--server.port=9000`) to a `property` and adds them to the Spring Environment.
기본적으로 SpringApplication은 `--server.port = 9000` 같은 `--`로 시작하는 모든 command line option arguments를 `property`으로 변환하고 이를 Spring Environment에 추가합니다.

As mentioned previously, command line properties always take precedence over other property sources.
앞서 언급했듯이 command line properties은 항상 다른 속성 소스보다 우선합니다.

If you do not want command line properties to be added to the Environment, you can disable them by using `SpringApplication.setAddCommandLineProperties(false)`.
Environment에 command line properties을 추가하지 않으려면 `SpringApplication.setAddCommandLineProperties (false)`를 사용하여 명령 줄 속성을 비활성화 할 수 있습니다.

####24.3 Application Property Files
`SpringApplication` loads properties from `application.properties` files in the following locations and adds them to the Spring Environment:
`SpringApplication`은 `application.properties` 파일의 속성을 다음 위치에 로드하고 Spring Environment에 추가합니다.

1. A `/config` subdirectory of the current directory
현재 디렉토리의 서브 디렉토리 (`/config`)
2. The current directory
현재 디렉토리
3. A classpath `/config` `package`
classpath 의 `/config` `패키지`
4. The classpath root
classpath 루트(root)

The list is ordered by precedence (properties defined in locations higher in the list override those defined in lower locations).
목록은 우선 순위에 따라 정렬됩니다 (목록의 상위 위치에 정의 된 속성은 하위 위치에 정의 된 속성보다 우선합니다).

>:bulb:
You can also [use YAML ('.yml') files](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-yaml) as an alternative to '.properties'.
'.properties' 대신 [YAML ( '.yml') 파일을 사용](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-yaml)할 수 있습니다.

If you do not like `application.properties` as the configuration file name, you can switch to another file name by specifying a `spring.config.name` environment property.
`application.properties`가 구성 파일 이름으로 맘에 들지 않으면 `spring.config.name` 환경 등록 정보를 지정하여 다른 파일 이름으로 전환 할 수 있습니다.

You can also refer to an explicit location by using the `spring.config.location` environment property (which is a comma-separated list of directory locations or file paths).
`spring.config.location` 환경 등록 정보(property) (쉼표로 구분 된 디렉토리 위치 또는 파일 경로)를 사용하여 명시적으로 위치를 참조 할 수도 있습니다.

The following example shows how to specify a different file name:
다음 예제에서는 다른 파일 이름을 지정하는 방법을 보여줍니다.

```
$ java -jar myproject.jar --spring.config.name=myproject
```
The following example shows how to specify two locations:
다음 예제에서는 두 위치를 지정하는 방법을 보여줍니다.
```
$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
```
> :exclamation:
`spring.config.name` and `spring.config.location` are used very early to determine which files have to be loaded, so they must be defined as an environment property (typically an OS environment variable, a system property, or a command-line argument).
`spring.config.name` 및 `spring.config.location`은 로드해야 할 파일을 결정하기 때문에 매우 일찍 사용되므로 환경 속성 (일반적으로 OS 환경 변수(OS environment variable), system property 또는 command-line argument로 정의해야 함)).

If `spring.config.location` contains directories (as opposed to files), they should end in `/` (and, at runtime, be appended with the names generated from `spring.config.name` before being loaded, including profile-specific file names).
`spring.config.location`에 파일이 아닌 디렉토리가 있으면 `/`에서 끝나야하며 (런타임에 `spring.config.name`에서 생성 된 이름을 프로파일 고유 파일 이름을 포함하여 로드하기 전에 런타임에 추가해야합니다).

Files specified in `spring.config.location` are used as-is, with no support for profile-specific variants, and are overridden by any profile-specific properties.
`spring.config.location`에 지정된 파일은 프로파일 별 변형을 지원하지 않고있는 그대로 사용되며 모든 프로파일 별 등록 정보로 대체됩니다.

Config locations are searched in reverse order.
구성 위치는 역순으로 검색됩니다.

By default, the configured locations are `classpath:/,classpath:/config/,file:./,file:./config/`. The resulting search order is the following:
기본적으로 구성된 위치는 `classpath:/,classpath:/config/,file:./,file:./config/`입니다. 결과 검색 순서는 다음과 같습니다.

1. `file:./config/`
2. `file:./`
3. `classpath:/config/`
4. `classpath:/`

When custom config locations are configured by using `spring.config.location`, they replace the default locations.
`spring.config.location`을 사용하여 '사용자 지정 구성 위치'(custom config locations)를 구성하면 기본 위치가 바뀝니다.

For example, if `spring.config.location` is configured with the value `classpath:/custom-config/,file:./custom-config/`, the search order becomes the following:
예를 들어, `spring.config.location`이 `classpath : / custom-config /, file : ./custom- config /` 값으로 구성되어 있으면 검색 순서는 다음과 같습니다.

1. `file:./custom-config/`
2. `classpath:custom-config/`

Alternatively, when custom config locations are configured by using `spring.config.additional-location`, they are used in addition to the default locations.
또는 `spring.config.additional-location`을 사용하여 '사용자 지정 구성 위치'(custom config locations)를 구성하면 기본 위치 외에 사용됩니다.

Additional locations are searched before the default locations.
추가 위치는 기본 위치보다 먼저 검색됩니다.

For example, if additional locations of `classpath:/custom-config/,file:./custom-config/ are configured`, the search order becomes the following:
예를 들어, `classpath : / custom-config /, file : ./ custom-config /`의 추가 위치가 구성된 경우 검색 순서는 다음과 같습니다.

1. file:./custom-config/
2. classpath:custom-config/
3. file:./config/
4. file:./
5. classpath:/config/
6. classpath:/

This search ordering lets you specify default values in one configuration file and then selectively override those values in another.
이 검색 순서 지정을 사용하면 하나의 구성 파일에 기본값을 지정한 다음 다른 값으로 선택적으로 무시할 수 있습니다.

You can provide default values for your application in `application.properties` (or whatever other basename you choose with `spring.config.name`) in one of the default locations.
`application.properties` (또는 `spring.config.name`으로 선택한 다른 기본 이름)의 기본 위치를 기본 위치 중 하나에 제공 할 수 있습니다.

These default values can then be overridden at runtime with a different file located in one of the custom locations.
이러한 기본값은 런타임에 사용자 정의 위치(custom locations) 중 하나에있는 다른 파일로 대체 될 수 있습니다.

>:bulb:
If you use environment variables rather than system properties, most operating systems disallow period-separated key names, but you can use underscores instead (for example, `SPRING_CONFIG_NAME` instead of `spring.config.name`).
시스템 등록 정보 대신 환경 변수를 사용하면 대부분의 운영 체제에서 마침표로 구분 된 키 이름을 사용할 수 없지만 대신 밑줄을 사용할 수 있습니다 (예 : `spring.config.name` 대신 `SPRING_CONFIG_NAME`).

>:bulb:
If your application runs in a container, then JNDI properties (in `java:comp/env`) or servlet context initialization parameters can be used instead of, or as well as, environment variables or system properties.
응용 프로그램이 컨테이너에서 실행되는 경우 환경 변수 또는 시스템 등록 정보 대신 JNDI properties (`java : comp / env`) 또는 서블릿 컨텍스트 초기화 매개 변수를 사용할 수 있습니다.

####24.4 Profile-specific Properties
In addition to `application.properties` files, profile-specific properties can also be defined by using the following naming convention: `application-{profile}.properties`.
`application.properties` 파일 뿐만 아니라 `application- {profile} .properties`와 같은 이름 지정 규칙을 사용하여 프로필 관련 등록 정보를 정의 할 수도 있습니다.

The Environment has a set of default profiles (by default, `[default])` that are used if no active profiles are set. In other words, if no profiles are explicitly activated, then properties from `application-default.properties` are loaded.
환경에는 활성 프로파일이 설정되지 않은 경우 사용되는 일련의 기본 프로파일 (기본적으로 `[default]`)이 있습니다. 즉, 명시적으로 활성화 된 프로파일이 없으면 `application-default.properties`의 특성이 로드됩니다.

Profile-specific properties are loaded from the same locations as standard `application.properties`, with profile-specific files always overriding the non-specific ones, whether or not the profile-specific files are inside or outside your packaged jar.
프로파일 특정 파일은 표준 `application.properties`와 동일한 위치에서 로드되며, 프로파일 특정 파일이 패키지 된 jar의 내부 또는 외부에 있는지에 관계없이 '프로파일 특정'(profile-specific) 파일이 항상 '특정 아닌'(profile-non-specific) 파일을 대체합니다.

If several profiles are specified, a last-wins strategy applies.
여러 개의 프로필이 지정되면 last-wins strategy가 적용됩니다.

For example, profiles specified by the `spring.profiles.active` property are added after those configured through the `SpringApplication` API and therefore take precedence.
예를 들어, `spring.profiles.active` 속성으로 지정된 프로파일은 `SpringApplication` API를 통해 구성된 프로파일 다음에 추가되므로 우선 적용됩니다.

>:bulb:
If you have specified any files in `spring.config.location`, profile-specific variants of those files are not considered.
`spring.config.location`에 파일을 지정한 경우 해당 파일의 프로파일 별 변형은 고려되지 않습니다.
Use directories in `spring.config.location` if you want to also use profile-specific properties.
프로필 관련 등록 정보도 사용하려면 `spring.config.location`의 디렉토리를 사용하십시오.

####24.5 Placeholders in Properties
The values in `application.properties` are filtered through the existing Environment when they are used, so you can refer back to previously defined values (for example, from System properties).
`application.properties`의 값은 사용되는 경우 기존 환경을 통해 필터링되므로 이전에 정의 된 값 (예 : 시스템 속성)을 다시 참조 할 수 있습니다.

```ini
app.name=MyApp
app.description=${app.name} is a Spring Boot application
```
>:bulb:
You can also use this technique to create “short” variants of existing Spring Boot properties.
이 기술을 사용하여 기존의 Spring Boot 속성의 “short” 변형을 만들 수도 있습니다.
See the [Section 77.4, “Use ‘Short’ Command Line Arguments”](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-use-short-command-line-arguments) how-to for details.
자세한 내용은 [Section 77.4, “Use ‘Short’ Command Line Arguments”](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-use-short-command-line-arguments)을 참조하십시오.

####24.6 Encrypting Properties
Spring Boot does not provide any built in support for encrypting property values, however, it does provide the hook points necessary to modify values contained in the Spring `Environment`.
Spring Boot는 속성 값 암호화를 위한 내장 된 지원을 제공하지 않지만 Spring `Environment`에 포함 된 값을 수정하는 데 필요한 후크 포인트(hook points)를 제공합니다.

The `EnvironmentPostProcessor` interface allows you to manipulate the `Environment` before the application starts.
`EnvironmentPostProcessor` 인터페이스를 사용하면 응용 프로그램이 시작되기 전에 `Environment`을 조작 할 수 있습니다.

See [Section 76.3, “Customize the Environment or ApplicationContext Before It Starts”](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-spring-boot-application.html#howto-customize-the-environment-or-application-context) for details.
자세한 내용은 [Section 76.3, “Customize the Environment or ApplicationContext Before It Starts”](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-spring-boot-application.html#howto-customize-the-environment-or-application-context)를 참조하십시오.

If you’re looking for a secure way to store credentials and passwords, the [Spring Cloud Vault](https://cloud.spring.io/spring-cloud-vault/) project provides support for storing externalized configuration in [HashiCorp](https://www.vaultproject.io/) Vault.
자격 증명과 패스워드를 안전하게 저장하는 방법을 찾고 있다면, [Spring Cloud Vault](https://cloud.spring.io/spring-cloud-vault/) 프로젝트는 [HashiCorp](https://www.vaultproject.io/) Vault에 외부화 된 설정을 저장하는 것을 지원한다.

####24.7 Using YAML Instead of Properties
[YAML](https://yaml.org/) is a superset of JSON and, as such, is a convenient format for specifying hierarchical configuration data.
[YAML](https://yaml.org/)은 JSON의 상위 집합(superset)이며, 따라서 계층적 구성 데이터를 지정하는 데 편리한 형식입니다.

The `SpringApplication` class automatically supports YAML as an alternative to properties whenever you have the [SnakeYAML](https://bitbucket.org/asomov/snakeyaml) library on your classpath.
`SpringApplication` 클래스는 classpath에 [SnakeYAML](https://bitbucket.org/asomov/snakeyaml) 라이브러리가 있을 때마다 YAML을 속성의 대안으로 자동 지원합니다.

>:bulb:
If you use “Starters”, SnakeYAML is automatically provided by `spring-boot-starter`.
"Starters"를 사용하면 SnakeYAML은 `spring-boot-starter`에 의해 자동으로 제공됩니다.

####24.7.1 Loading YAML
Spring Framework provides two convenient classes that can be used to load YAML documents.
Spring Framework는 YAML 문서를 로드하는 데 사용할 수있는 두 가지 편리한 클래스를 제공합니다.

The `YamlPropertiesFactoryBean` loads YAML as `Properties` and the `YamlMapFactoryBean` loads YAML as a `Map`.
`YamlPropertiesFactoryBean`은 YAML을 `Properties`로 로드하고 `YamlMapFactoryBean`은 YAML을 `Map`으로 드합니다.

For example, consider the following YAML document:
예를 들어 다음 YAML 문서를 생각해보십시오.

```properties
environments:
	dev:
		url: https://dev.example.com
		name: Developer Setup
	prod:
		url: https://another.example.com
		name: My Cool App
```
The preceding example would be transformed into the following properties:
앞의 예는 다음 속성으로 변환됩니다.

```properties
environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App
```

YAML lists are represented as property keys with `[index]` dereferencers.
YAML리스트는 `[index]` dereferencers와 함께 속성 keys로 표현됩니다.

For example, consider the following YAML:
예를 들어, 다음 YAML을 고려하십시오.

```properties
my:
servers:
	- dev.example.com
	- another.example.com
```
The preceding example would be transformed into these properties:
앞의 예는 다음 속성으로 변환됩니다.

```properties
my.servers[0]=dev.example.com
my.servers[1]=another.example.com
```
To bind to properties like that by using Spring Boot’s `Binder` utilities (which is what `@ConfigurationProperties` does), you need to have a property in the target bean of type `java.util.List` (or `Set`) and you either need to provide a setter or initialize it with a mutable value.
Spring Boot의 `Binder` 유틸리티 (`@ConfigurationProperties`의 기능)를 사용하여 이와 같은 속성에 바인딩하려면 `java.util.List` (또는 `Set`) 유형의 대상 bean에 속성이 있어야하며 setter를 제공해야하며 변경할 수있는 값으로 초기화하십시오.

For example, the following example binds to the properties shown previously:
예를 들어 다음 예제는 이전에 표시된 속성에 바인딩합니다.

```java
@ConfigurationProperties(prefix="my")
public class Config {

	private List<String> servers = new ArrayList<String>();

	public List<String> getServers() {
		return this.servers;
	}
}
```

####24.7.2 Exposing YAML as Properties in the Spring Environment
The `YamlPropertySourceLoader` class can be used to expose YAML as a `PropertySource` in the Spring `Environment`.
`YamlPropertySourceLoader` 클래스는 Spring `Environment`에서 YAML을 `PropertySource`로 노출시키는 데 사용될 수 있습니다.

Doing so lets you use the `@Value` annotation with placeholders syntax to access YAML properties.
이렇게 하면 '자리 표시 자 구문'(placeholders syntax)으로 `@Value` annotation을 사용하여 YAML 속성에 접근  할 수 있습니다.

####24.7.3 Multi-profile YAML Documents
You can specify multiple profile-specific YAML documents in a single file by using a `spring.profiles` key to indicate when the document applies, as shown in the following example:
다음 예제와 같이 `spring.profiles` key를 사용하여 문서가 적용되는 시기를 나타내는 단일 프로필에 여러 프로필 관련 YAML 문서를 지정할 수 있습니다.

```properties
server:
	address: 192.168.1.100
---
spring:
	profiles: development
server:
	address: 127.0.0.1
---
spring:
	profiles: production & eu-central
server:
	address: 192.168.1.120
```

In the preceding example, if the `development` profile is active, the `server.address` property is `127.0.0.1`.
앞의 예에서 `development` 프로필이 활성화 된 경우 `server.address` 속성은 `127.0.0.1`입니다.

Similarly, if the `production` **and** `eu-central` profiles are active, the `server.address` property is `192.168.1.120`.
마찬가지로 `production` 또는 `eu-central` 프로필이 활성화 된 경우 `server.address` 속성은 `192.168.1.120`입니다.

If the `development`, `production` and `eu-central` profiles are **not** enabled, then the value for the property is `192.168.1.100`.
`development`, `production` 또는 `eu-central` 프로파일이 활성화되지 **않은** 경우 속성 값은 `192.168.1.100`입니다.

>:bulb:
`spring.profiles` can therefore contain a simple profile name (for example `production`) or a profile expression.
`spring.profiles`는 간단한 프로파일 이름 (예 : `production`) 또는 프로파일 표현식을 포함 할 수 있습니다.
A profile expression allows for more complicated profile logic to be expressed, for example `production & (eu-central | eu-west)`. Check the reference guide for more details.
프로파일 표현식은 `production & (eu-central | eu-west)` 과 같은 좀 더 복잡한 프로파일 로직을 표현하는 것을 허용한다. 
Check [the reference guide](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java) for more details.
자세한 내용은 [참조 가이드](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java)를 확인하십시오.

If none are explicitly active when the application context starts, the default profiles are activated.
응용 프로그램 컨텍스트가 시작될 때 명시적으로 활성화 된 것이 없으면 기본 프로파일이 활성화됩니다.

So, in the following YAML, we set a value for `spring.security.user.password` that is available **only** in the "default" profile:
따라서 다음 YAML에서는 "default" 프로필에서**만** 사용 할 수 있는 `spring.security.user.password` 값을 설정합니다.

```properties
server:
	port: 8000
---
spring:
	profiles: default
	security:
	user:
		password: weak
```
Whereas, in the following example, the password is always set because it is not attached to any profile, and it would have to be explicitly reset in all other profiles as necessary:
다음 예제에서 암호는 프로파일에 연결되지 않았기 때문에 항상 설정되며 필요에 따라 다른 모든 프로파일에서 명시적으로 재설정해야합니다.

```properties
server:
	port: 8000
spring:
	security:
	user:
		password: weak
```

Spring profiles designated by using the `spring.profiles` element may optionally be negated by using the `!` character.
`spring.profiles`요소를 사용하여 지정된(designated) 스프링 프로파일은 선택적으로 `!`문자를 사용하여 무효화 될 수 있습니다.

If both negated and non-negated profiles are specified for a single document, at least one non-negated profile must match, and no negated profiles may match.
단일 문서에 대해 'non-negated profiles' 및 'specified profiles'가 모두 지정되면, 적어도 'non-negated profile'이 일치해야하며 no negated profiles may match.

> no negated profiles may match.: ????????????????

####24.7.4 YAML Shortcomings
YAML files cannot be loaded by using the `@PropertySource` annotation.
`@PropertySource` annotation을 사용하여 YAML 파일을 로드 할 수 없습니다.

So, in the case that you need to load values that way, you need to use a properties file.
그런 식으로 값을 로드해야하는 경우 속성 파일을 사용해야합니다.

Using the multi YAML document syntax in profile-specific YAML files can lead to unexpected behavior.
프로필 관련 YAML 파일에서 다중 YAML 문서 구문을 사용하면 예기치 않은 동작이 발생할 수 있습니다.

For example, consider the following config in a file called `application-dev.yml`, with the `dev` profile being active:
예를 들어, `dev` profile이 활성 상태 인 `application-dev.yml` 파일에서 다음 구성을 고려하십시오.

```properties
server:
	port: 8000
---
spring:
	profiles: !test
	security:
		user:
			password: weak
```

In the example above, profile negation and profile expressions will not behave as expected.
위의 예에서 프로필 부정(!) 및 프로필 식은 예상대로 작동하지 않습니다.

We recommend that you don’t combine profile-specific YAML files and multiple YAML documents and stick to using only one of them.
프로필 별 YAML 파일과 여러 YAML 문서를 결합하지 말고 하나만 사용하는 것이 좋습니다.

####24.8 Type-safe Configuration Properties
Using the `@Value`(`"${property}"`) annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature.
`@Value` ( `"$ {property}"`) annotation을 사용하여 구성 등록 정보를 주입하는 것은 때로는 번거로울 수 있습니다. 특히 여러 속성으로 작업하거나 데이터가 본질적으로 계층적일 경우 특히 그렇습니다.

Spring Boot provides an alternative method of working with properties that lets strongly typed beans govern and validate the configuration of your application, as shown in the following example:
Spring Boot는 다음 예제와 같이 강력하게 유형이 지정된 bean이 응용 프로그램의 구성을 관리하고 유효하게 하는 등록 정보로 작업하는 대체 방법을 제공합니다.

```java
package com.example;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("acme")
public class AcmeProperties {

	private boolean enabled;

	private InetAddress remoteAddress;

	private final Security security = new Security();

	public boolean isEnabled() { ... }

	public void setEnabled(boolean enabled) { ... }

	public InetAddress getRemoteAddress() { ... }

	public void setRemoteAddress(InetAddress remoteAddress) { ... }

	public Security getSecurity() { ... }

	public static class Security {

		private String username;

		private String password;

		private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

		public String getUsername() { ... }

		public void setUsername(String username) { ... }

		public String getPassword() { ... }

		public void setPassword(String password) { ... }

		public List<String> getRoles() { ... }

		public void setRoles(List<String> roles) { ... }

	}
}
```
The preceding POJO defines the following properties:
위의 POJO는 다음 속성을 정의합니다.

* `acme.enabled`, with a value of `false` by default.
`acme.enabled` (기본값은 `false`)
* `acme.remote-address`, with a type that can be coerced from String.
`acme.remote-address`는 String에서 강제 변환 할 수 있는 유형입니다.
* `acme.security.username`, with a nested "security" object whose name is determined by the `name` of the property.
`acme.security.username`은 속성 `name`으로 이름이 결정되는 중첩 된 "security"객체와 함께 사용됩니다.
In particular, the return type is not used at all there and could have been `SecurityProperties`.
특히 반환 type은 전혀 사용되지 않으며 `SecurityProperties`가 될 수 있습니다.
* `acme.security.password`.
`acme.security.password`.
* `acme.security.roles`, with a collection of String.
`acme.security.roles` (String 컬렉션 포함).

>:bulb:
Getters and setters are usually mandatory, since binding is through standard Java Beans property descriptors, just like in Spring MVC. 
Getter와 setter는 Spring MVC와 마찬가지로 표준 Java Beans 프로퍼티 디스크립터를 통해 바인딩되기 때문에 보통 필수이다.
A setter may be omitted in the following cases:
다음과 같은 경우에는 세터를 생략 할 수 있습니다.
>- Maps, as long as they are initialized, need a getter but not necessarily a setter, since they can be mutated by the binder.
Maps은 초기화되는 한 바인더의해 변경 될 수 있기 때문에 getter가 필요하지만 반드시 setter 일 필요는 없습니다.
>- Collections and arrays can be accessed either through an index (typically with YAML) or by using a single comma-separated value (properties).
Collections과 arrays은 '인덱스(일반적으로 YAML)' 또는 '쉼표로 구분 된 단일 값 (properties)'을 사용하여 액세스 할 수 있습니다.
In the latter case, a setter is mandatory.
후자의 경우 setter는 필수입니다.
We recommend to always add a setter for such types.
이러한 유형의 경우 setter를 항상 추가하는 것이 좋습니다.
If you initialize a collection, make sure it is not immutable (as in the preceding example).
collection을 초기화하는 경우, collection이 불변이 아닌지 확인하십시오 (앞의 예와 같이).
>- If nested POJO properties are initialized (like the `Security` field in the preceding example), a setter is not required.
앞의 예제에서 `Security` 필드와 같이 중첩 된 POJO 속성이 초기화되면 setter가 필요하지 않습니다.
If you want the binder to create the instance on the fly by using its default constructor, you need a setter.
바인더가 기본 생성자를 사용하여 즉석에서 인스턴스를 만들려면 setter가 필요합니다.

>:bulb:
Some people use Project Lombok to add getters and setters automatically.
어떤 사람들은 Project Lombok을 사용하여 getter와 setter를 자동으로 추가합니다.
Make sure that Lombok does not generate any particular constructor for such a type, as it is used automatically by the container to instantiate the object.
Lombok이 컨테이너에서 자동으로 개체를 인스턴스화 할 때 사용되는 특정 형식의 생성자를 생성하지 않았는지 확인해야 합니다.

Finally, only standard Java Bean properties are considered and binding on static properties is not supported.
마지막으로 표준 Java Bean properties 만 고려되며 정적 특성에 대한 바인딩은 지원되지 않습니다.

>:bulb:
See also the [differences between @Value and @ConfigurationProperties](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-vs-value).
[@Value와 @ConfigurationProperties의 차이점](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-vs-value)을 참조하십시오.

You also need to list the properties classes to register in the `@EnableConfigurationProperties` annotation, as shown in the following example:
또한 다음 예제와 같이 `@EnableConfigurationProperties` annotation에 등록 할 '속성 클래스'(properties classes)를 나열해야합니다.

```java
@Configuration
@EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration {

}
```

>:bulb:
When the `@ConfigurationProperties` bean is registered that way, the bean has a conventional name: `<prefix>-<fqn>`, where `<prefix>` is the environment key prefix specified in the `@ConfigurationProperties` annotation and <fqn> is the fully qualified name of the bean.
그런 식으로 `@ConfigurationProperties` 빈이 등록되면 빈은 `<prefix>-<fqn>`이라는 전통적인(관례적인, conventional) 이름을 갖습니다. 여기서 `<prefix>`는 `@ConfigurationProperties` annotation에 지정된 환경 키 접두사이고 <fqn>은 빈의 전체 네임(fully qualified name).
If the annotation does not provide any prefix, only the fully qualified name of the bean is used.
The bean name in the example above is `acme-com.example.AcmeProperties`.
annotation이 접두어를 제공하지 않으면 bean의 완전한 이름(fully qualified name) 만 사용됩니다.
위 예의 빈 이름은 `acme-com.example.AcmeProperties`입니다.

The preceding configuration creates a regular bean for `AcmeProperties`.
앞의 구성은 `AcmeProperties`에 대한 일반 bean을 작성합니다.

We recommend that `@ConfigurationProperties` only deal with the environment and, in particular, does not inject other beans from the context.
`@ConfigurationProperties`는 environment만을 처리도록 하고, 특히 컨텍스트에서 다른 빈을 삽입하지 않는 것이 좋습니다.

Keep in mind that the @EnableConfigurationProperties annotation is also ***automatically applied*** to your project so that any ***existing*** bean annotated with `@ConfigurationProperties` is configured from the Environment.
`@EnableConfigurationProperties` annotation은 프로젝트에 ***자동으로 적용*** 되어 `@ConfigurationProperties`로 annotation이 된 ***기존*** Bean이 환경에서 구성되도록 하십시오.

Instead of annotating `MyConfiguration` with `@EnableConfigurationProperties(AcmeProperties.class)`, you could make `AcmeProperties` a bean, as shown in the following example:
`@EnableConfigurationProperties (AcmeProperties.class)`로 `MyConfiguration`에 주석을 추가하는 대신 다음 예제와 같이 `AcmeProperties`를 bean으로 만들 수 있습니다.

```java
@Component
@ConfigurationProperties(prefix="acme")
public class AcmeProperties {

	// ... see the preceding example

}
```

This style of configuration works particularly well with the `SpringApplication` external YAML configuration, as shown in the following example:
이 구성 스타일은 `SpringApplication` 외부 YAML 구성에서 특히 잘 작동합니다 (다음 예제 참조).

```properties
# application.yml

acme:
	remote-address: 192.168.1.1
	security:
		username: admin
		roles:
		  - USER
		  - ADMIN

# additional configuration as required
```

To work with `@ConfigurationProperties` beans, you can inject them in the same way as any other bean, as shown in the following example:
`@ConfigurationProperties` 빈을 사용하여 작업하려면 다음 예제와 같이 다른 빈과 동일한 방법으로 이를 삽입 할 수 있습니다.

```java
@Service
public class MyService {

	private final AcmeProperties properties;

	@Autowired
	public MyService(AcmeProperties properties) {
	    this.properties = properties;
	}

 	//...

	@PostConstruct
	public void openConnection() {
		Server server = new Server(this.properties.getRemoteAddress());
		// ...
	}

}
```

>:bulb:
Using `@ConfigurationProperties` also lets you generate metadata files that can be used by IDEs to offer auto-completion for your own keys.
`@ConfigurationProperties`를 사용하면 IDE가 자신의 키에 대한 자동 완성을 제공하는 데 사용할 수 있는 메타 데이터 파일을 생성 할 수 있습니다.

See the [Appendix B, Configuration Metadata appendix](https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html) for details.
자세한 내용은 [Appendix(부록) B, Configuration Metadata appendix](https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html)을 참조하십시오.

####24.8.1 Third-party Configuration
As well as using `@ConfigurationProperties` to annotate a class, you can also use it on public `@Bean` methods.
`@ConfigurationProperties`를 사용하여 클래스에 annotation을 추가하는 것은 물론 public `@Bean` 메소드에서도 사용할 수 있습니다.

Doing so can be particularly useful when you want to bind properties to third-party components that are outside of your control.
이렇게하면 컨트롤 외부에있는 third-party components에 속성을 바인딩하려는 경우 특히 유용 할 수 있습니다.

To configure a bean from the Environment properties, add `@ConfigurationProperties` to its bean registration, as shown in the following example:
Environment properties에서 bean을 구성하려면 다음 예와 같이 Bean 등록에 `@ConfigurationProperties`를 추가하십시오.

```java
@ConfigurationProperties(prefix = "another")
@Bean
public AnotherComponent anotherComponent() {
	...
}
```
Any property defined with the `another` prefix is mapped onto that `AnotherComponent` bean in manner similar to the preceding `AcmeProperties` example.
`다른` 접두어로 정의 된 특성은 이전 `AcmeProperties` 예제와 유사한 방식으로 해당 `AnotherComponent` Bean에 맵핑됩니다.

###24.8.2 Relaxed Binding
Spring Boot uses some relaxed rules for binding `Environment` properties to `@ConfigurationProperties` beans, so there does not need to be an exact match between the `Environment` property name and the bean property name.
Spring Boot는 `Environment` properties를 `@ConfigurationProperties` 빈에 바인딩하기 위한 다소 완화 된 규칙을 사용하므로 `Environment` property name과 Bean property name이 정확히 일치 할 필요는 없습니다.

Common examples where this is useful include dash-separated environment properties (for example, `context-path` binds to `contextPath`), and capitalized environment properties (for example, `PORT` binds to `port`).
이것이 유용한 일반적인 예는 대시로 구분 된 환경 등록 정보 (예 : `context-path`가 `contextPath`에 바인드 함) 및 대문자로 된 환경 등록 정보 (예 : `PORT`가 `port`에 바인드 함)를 포함합니다.

For example, consider the following @ConfigurationProperties class:
예를 들어, 다음과 같은 @ConfigurationProperties 클래스를 고려하십시오.

```java
@ConfigurationProperties(prefix="acme.my-project.person")
public class OwnerProperties {

	private String firstName;

	public String getFirstName() {
		return this.firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

}
```
In the preceding example, the following properties names can all be used:
앞의 예제에서 다음 속성 이름을 모두 사용할 수 있습니다.

######Table 24.1. relaxed binding

Property
Note

`acme.my-project.person.first-name`
- Kebab case, which is recommended for use in `.properties` and `.yml` files.
Kebab 케이스, `.properties` 및 `.yml` 파일에서 사용하는 것이 좋습니다.

`acme.myProject.person.firstName`
- Standard camel case syntax.
표준 camel case 구문.

`acme.my_project.person.first_name`
- Underscore notation, which is an alternative format for use in `.properties` and `.yml` files.
밑줄 표기법, `.properties` 및 `.yml` 파일에서 사용하기 위한 대체 형식입니다.

`ACME_MYPROJECT_PERSON_FIRSTNAME`
- Upper case format, which is recommended when using system environment variables.
시스템 환경 변수를 사용할 때 권장되는 대문자 형식.

>:bulb:
The `prefix` value for the annotation must be in kebab case (`lowercase` and separated by `-`, such as `acme.my-project.person`).
annotation의 `접두사` 값은 kebab case 여야 합니다 (`소문자`이고 `-`로 구분됨, 예 : `acme.my-project.person`).

######Table 24.2. relaxed binding rules per property source

Property Source
Simple
List

* Properties Files
  - Camel case, kebab case, or underscore notation
  Camel case, kebab case 또는 밑줄 표기법
  - Standard list syntax using `[ ]` or `comma-separated` values
  `[]` 또는 `쉼표로 구분` 된 값을 사용하는 표준 목록 구문
* YAML Files
  - Camel case, kebab case, or underscore notation
  Camel case, kebab case 또는 밑줄 표기법
  - `Standard YAML list syntax` or `comma-separated` values
  `표준 YAML 목록 구문` 또는 `쉼표로 구분` 된 값
* Environment Variables
  - Upper case format with underscore as the delimiter.
  분리 문자로 밑줄이 있는 대문자 형식입니다.
  `_` should not be used within a property name
  `_` 문자는 속성 이름 내에서 사용하면 안됩니다.
  - Numeric values surrounded by underscores, such as `MY_ACME_1_OTHER = my.acme[1].other`
  `MY_ACME_1_OTHER = my.acme [1]`과 같이 밑줄로 묶인 숫자 값. 기타
* System properties
  - Camel case, kebab case, or underscore notation
  Camel case, kebab case 또는 밑줄 표기법
  - `Standard list syntax` using `[ ]` or `comma-separated` values
  `[]` 또는 `쉼표로 구분` 된 값을 사용하는 `표준 목록 구문`

>:bulb:
We recommend that, when possible, properties are stored in `lower-case kebab format`, such as `my.property-name=acme`.
가능하면 속성은 `my.property-name = acme`와 같이 `소문자 kebab 형식`으로 저장하는 것이 좋습니다.

When binding to Map properties, if the `key` contains anything other than lowercase alpha-numeric characters or `-`, you need to use the bracket notation so that the original value is preserved.
Map 속성에 바인딩 할 때 `key`에 소문자 영숫자 또는 `-` 이외의 문자가 포함되어 있으면 원래 값이 유지되도록 대괄호 표기법을 사용해야합니다.

> alpha-numeric : ex) v1, 320i, K7, Gr8(great), B4(before), 2more(tomorrow), Some1(someone) etc..

If the key is not surrounded by `[]`, any characters that are not alpha-numeric or `-` are removed. For example, consider binding the following properties to a Map:
key가 `[]`로 둘러싸여 있지 않으면 영문자가 아니거나 `-` 인 문자는 모두 제거됩니다. 예를 들어 다음 속성을 Map에 바인딩하는 것을 고려하십시오.

```properties
acme:
	map:
		"[/key1]": value1
		"[/key2]": value2
		/key3: value3
```

The properties above will bind to a Map with `/key1`, `/key2` and `key3` as the keys in the map.
위의 속성은 `/ key1`, `/ key2` 및 `key3`을 Map의 keys로 사용하여 Map에 바인딩됩니다.

####24.8.3 Merging Complex Types
When lists are configured in more than one place, overriding works by replacing the entire list.
둘 이상의 장소에서 목록이 구성된 경우 전체 목록을 대체하여 우선 적용됩니다.

For example, assume a `MyPojo` object with `name` and `description` attributes that are `null` by default.
예를 들어, 기본적으로 `null` 인 `name` 및 `description` 속성을 가진 `MyPojo` 객체를 가정합니다.

The following example exposes a list of `MyPojo` objects from `AcmeProperties`:
다음 예제에서는 `AcmeProperties`에서 `MyPojo` 개체의 목록을 노출합니다.

```java
@ConfigurationProperties("acme")
public class AcmeProperties {

	private final List<MyPojo> list = new ArrayList<>();

	public List<MyPojo> getList() {
		return this.list;
	}

}
```
Consider the following configuration:
다음 구성을 고려하십시오.

```properties
acme:
	list:
		- name: my name
		  description: my description
---
spring:
	profiles: dev
acme:
	list:
		- name: my another name
```

If the `dev` profile is not active, `AcmeProperties.list` contains one `MyPojo` entry, as previously defined.
`dev` 프로필이 활성화되어 있지 않으면 `AcmeProperties.list`에 앞서 정의 된대로 `MyPojo` 항목이 하나 있습니다.

If the dev profile is enabled, however, the `list` still contains only one entry (with a name of `my another name` and a description of null).
그러나 `dev` 프로필을 사용하는 경우 `list`에는 하나의 항목 (`my another name`과 null값을 갖는 description 포함) 만 포함됩니다.

This configuration does not add a second `MyPojo` instance to the list, and it does not merge the items.
이 구성은 두 번째 `MyPojo` 인스턴스를 list에 추가하지 않으며 항목을 병합하지 않습니다.

When a `List` is specified in multiple profiles, the one with the highest priority (and only that one) is used.
`목록`이 여러 프로필에 지정된 경우 우선 순위가 가장 높은 프로필 만 사용됩니다.

Consider the following example:
다음 예제를 고려하십시오.

```properties
acme:
	list:
	- name: my name
	  description: my description
	- name: another name
	  description: another description
---
spring:
	profiles: dev
acme:
	list:
	- name: my another name
```

In the preceding example, if the `dev` profile is active, `AcmeProperties.list` contains one `MyPojo` entry (with a `name` of `my another name` and a `description` of `null`).
앞의 예에서 `dev` 프로필이 활성화되어 있으면 `AcmeProperties.list`에 `MyPojo` 항목이 하나 있습니다 (`name`이 `my another name`이고 `description`이 `null` 임).

For YAML, both comma-separated lists and YAML lists can be used for completely overriding the contents of the list.
YAML의 경우 쉼표로 구분 된 목록과 YAML 목록을 모두 사용하여 목록의 내용을 완전히 무시할 수 있습니다.

For Map properties, you can bind with property values drawn from multiple sources.
Map 속성의 경우 여러 소스에서 가져온 속성 값으로 바인딩 할 수 있습니다.

However, for the same property in multiple sources, the one with the highest priority is used.
그러나 여러 소스에서 동일한 속성의 경우 우선 순위가 가장 높은 속성이 사용됩니다.

The following example exposes a Map<String, MyPojo> from AcmeProperties:
다음 예제에서는 AcmeProperties에서 Map <String, MyPojo>를 보여줍니다.

```java
@ConfigurationProperties("acme")
public class AcmeProperties {

	private final Map<String, MyPojo> map = new HashMap<>();

	public Map<String, MyPojo> getMap() {
		return this.map;
	}

}
```
Consider the following configuration:
다음 구성을 고려하십시오.

```properties
acme:
	map:
		key1:
			name: my name 1
			description: my description 1
---
spring:
	profiles: dev
acme:
	map:
		key1:
			name: dev name 1
		key2:
			name: dev name 2
			description: dev description 2
```

If the `dev` profile is not active, `AcmeProperties.map` contains one entry with key `key1` (with a `name` of `my name 1` and a `description` of `my description 1`).
`dev` 프로필이 활성화되어 있지 않으면 `AcmeProperties.map`에 키가 `key1`인 항목이 하나 있습니다 (`name`이 `my name 1`이고 `description`이 `my description 1`).

If the `dev` profile is enabled, however, map contains two entries with keys `key1` (with a `name` of `dev name 1` and a `description` of `my description 1`) and key2 (with a `name` of `dev name 2` and a `description` of `dev description 2`).
그러나 `dev` 프로필을 사용하는 경우 map에는 키가 `key1`(`name`이 `dev name 1`이고 `description`이 `my description 1`)과 `key2` (`name`이 `dev name 2`이고 `description`이 `dev description 2`) 라는 두개의 항목이 있습니다.

>:bulb:
The preceding merging rules apply to properties from all property sources and not just YAML files.
위의 병합 규칙은 YAML 파일뿐만 아니라 모든 속성 소스의 속성에도 적용됩니다.

####24.8.4 Properties Conversion
Spring Boot attempts to coerce the external application properties to the right type when it binds to the `@ConfigurationProperties` beans.
Spring Boot는 `@ConfigurationProperties` beans에 바인드 할 때 외부 애플리케이션 특성을 올바른 유형으로 강제 변환하려고 시도합니다.

If you need custom type conversion, you can provide a `ConversionService` bean (with a bean named `conversionService`) or custom property editors (through a CustomEditorConfigurer bean) or custom Converters (with bean definitions annotated as `@ConfigurationPropertiesBinding`).
custom type 으로 변환이 필요한 경우 `conversionService` bean (`conversionService` bean) 또는 사용자 정의 특성 편집기(custom property editors) (`CustomEditorConfigurer` bean을 통해) 또는 사용자 정의 Converters (Bean 정의가 `@ConfigurationPropertiesBinding`으로 annotation 됨)를 제공 할 수 있습니다.

>:bulb:
As this bean is requested very early during the application lifecycle, make sure to limit the dependencies that your ConversionService is using.
이 Bean은 애플리케이션 lifecycle 중 매우 일찍 요청되므로 `ConversionService`가 사용하는 종속성을 제한해야 합니다.
Typically, any dependency that you require may not be fully initialized at creation time.
일반적으로 필요한 종속성은 작성시 완전히 초기화되지 않을 수 있습니다.
You may want to rename your custom `ConversionService` if it is not required for configuration keys coercion and only rely on custom converters qualified with `@ConfigurationPropertiesBinding`.
configuration keys 강제 변환에 필요하지 않은 경우 사용자 지정 `ConversionService`의 이름을 바꾸고 `@ConfigurationPropertiesBinding`으로 정규화 된 사용자 지정 변환기에만 의존 할 수 있습니다.

> qualified: 정규화

#####Converting durations
Spring Boot has dedicated support for expressing durations.
Spring Boot는 지속 시간 표현을 위한 전용 지원을 제공합니다.
If you expose a `java.time.Duration` property, the following formats in application properties are available:
`java.time.Duration` 속성을 노출하면 응용 프로그램 속성에서 다음 형식을 사용할 수 있습니다.

* A regular `long` representation (using milliseconds as the default unit unless a `@DurationUnit` has been specified)
`@DurationUnit`이 지정되지 않은 한 기본 단위로 밀리 초를 사용하는 일반 long 표현입니다.
* The standard ISO-8601 format [used by java.time.Duration](https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-)
[java.time.Duration에 의해 사용](https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-)되는 표준 ISO-8601 형식
* A more readable format where the value and the unit are coupled (e.g. 10s means 10 seconds)
값과 단위가 결합 된 더 읽기 쉬운 형식 (예 : 10s는 10 초를 의미 함)

Consider the following example:
다음 예제를 고려하십시오.

```java
@ConfigurationProperties("app.system")
public class AppSystemProperties {

	@DurationUnit(ChronoUnit.SECONDS)
	private Duration sessionTimeout = Duration.ofSeconds(30);

	private Duration readTimeout = Duration.ofMillis(1000);

	public Duration getSessionTimeout() {
		return this.sessionTimeout;
	}

	public void setSessionTimeout(Duration sessionTimeout) {
		this.sessionTimeout = sessionTimeout;
	}

	public Duration getReadTimeout() {
		return this.readTimeout;
	}

	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}

}
```

To specify a session timeout of 30 seconds, 30, PT30S and 30s are all equivalent.
세션 시간 초과를 30 초, 30, PT30S 및 30으로 지정하면 모두 동등해야합니다.

A read timeout of 500ms can be specified in any of the following form: 500, PT0.5S and 500ms.
500ms의 읽timeout은 500, PT0.5S 및 500ms 중 하나의 형식으로 지정할 수 있습니다.

You can also use any of the supported units. These are:
지원되는 유닛을 사용할 수도 있습니다. 이것들은:

* `ns` for nanoseconds
* `us` for microseconds
* `ms` for milliseconds
* `s` for seconds
* `m` for minutes
* `h` for hours
* `d` for days

The default unit is milliseconds and can be overridden using `@DurationUnit` as illustrated in the sample above.
기본 단위는 밀리 초(milliseconds)이며 위 샘플에 나와있는 것처럼 `@DurationUnit`을 사용하여 무시할 수 있습니다.

>:bulb:
If you are upgrading from a previous version that is simply using Long to express the duration, make sure to define the unit (using `@DurationUnit`) if it isn’t milliseconds alongside the switch to Duration.
기간을 표현하기 위해 단순히 Long을 사용하는 이전 버전에서 업그레이드하는 경우 Duration으로 전환 할 때 밀리 초가 아닌 경우 단위를 정의하십시오 (`@DurationUnit` 사용).
Doing so gives a transparent upgrade path while supporting a much richer format.
이렇게 하면 훨씬 더 풍부한 형식을 지원하면서 투명한 업그레이드 경로가 제공됩니다.

#####Converting Data Sizes
Spring Framework has a `DataSize` value type that allows to express size in bytes.
Spring Framework는 크기를 바이트 단위로 표현할 수있는 `DataSize` 값 유형을 가지고 있습니다.

If you expose a `DataSize` property, the following formats in application properties are available:
`DataSize` 속성을 표현한다면 응용 프로그램 속성에서 다음 형식을 사용할 수 있습니다.

* A regular long representation (using bytes as the default unit unless a `@DataSizeUnit` has been specified)
정규의 long 표현 (`@DataSizeUnit`가 지정되어 있지 않은 한 바이트를 기본 단위로 사용)
* A more readable format where the value and the unit are coupled (e.g. `10MB `means 10 megabytes)
값과 단위가 결합 된 더 읽기 쉬운 형식 (예 : `10MB`는 10 megabytes를 의미)

Consider the following example:
다음 예제를 고려하십시오.

```java
@ConfigurationProperties("app.io")
public class AppIoProperties {

	@DataSizeUnit(DataUnit.MEGABYTES)
	private DataSize bufferSize = DataSize.ofMegabytes(2);

	private DataSize sizeThreshold = DataSize.ofBytes(512);

	public DataSize getBufferSize() {
		return this.bufferSize;
	}

	public void setBufferSize(DataSize bufferSize) {
		this.bufferSize = bufferSize;
	}

	public DataSize getSizeThreshold() {
		return this.sizeThreshold;
	}

	public void setSizeThreshold(DataSize sizeThreshold) {
		this.sizeThreshold = sizeThreshold;
	}

}
```
To specify a buffer size of `10 megabytes`, 10 and 10MB are equivalent.
버퍼 크기를 10 메가 바이트로 지정하려면 `10`와 `10MB`가 동일합니다..

A size threshold of `256 bytes` can be specified as `256` or `256B`.
256 바이트의 크기 임계 값은 `256` 또는 `256B`로 지정할 수 있습니다.

You can also use any of the supported units. These are:
지원되는 유닛을 사용할 수도 있습니다. 이것들은:

* `B` for bytes
* `KB` for kilobytes
* `MB` for megabytes
* `GB` for gigabytes
* `TB` for terabytes

The default unit is bytes and can be overridden using `@DataSizeUnit` as illustrated in the sample above.
기본 단위는 바이트이며 위 샘플에서 설명한대로 `@DataSizeUnit`을 사용하여 재정의 할 수 있습니다.

>:bulb:
If you are upgrading from a previous version that is simply using `Long` to express the size, make sure to define the unit (using `@DataSizeUnit`) if it isn’t bytes alongside the switch to DataSize.
단순히 `Long`을 사용하여 크기를 표현하는 이전 버전에서 업그레이드하는 경우 DataSize 로의 전환과 함께 바이트가 아닌 경우 단위를 정의해야합니다 (`@DataSizeUnit` 사용).
Doing so gives a transparent upgrade path while supporting a much richer format.
이렇게 하면 훨씬 더 풍부한 형식을 지원하면서 투명한 업그레이드 경로가 제공됩니다.

####24.8.5 @ConfigurationProperties Validation
Spring Boot attempts to validate `@ConfigurationProperties` classes whenever they are annotated with Spring’s `@Validated` annotation.
Spring Boot는 `@ConfigurationProperties` 클래스가 스프링의 `@Validated` annotation으로 주석이 작성 될 때마다 유효성 검사를 시도합니다.

You can use JSR-303 `javax.validation` constraint annotations directly on your configuration class.
Configuration 클래스에서 JSR-303 `javax.validation` constraint(강제, 제약조건) annotation을 직접 사용할 수 있습니다.

To do so, ensure that a compliant JSR-303 implementation is on your classpath and then add constraint annotations to your fields, as shown in the following example:
이렇게 하려면 다음 예와 같이 호환되는 JSR-303 구현이 classpath에 있는지 확인한 다음 필드에 제약 조건 annotations을 추가하십시오.

```java
@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

	@NotNull
	private InetAddress remoteAddress;

	// ... getters and setters

}
```

>:bulb:
You can also trigger validation by annotating the `@Bean` method that creates the configuration properties with `@Validated`.
`@Validated`로 구성 등록 정보를 작성하는 `@Bean` 메소드에 annotation을 달아 유효성 검증을 트리거 할 수도 있습니다.

Although nested properties will also be validated when bound, it’s good practice to also annotate the associated field as `@Valid`.
중첩 된 속성도 바인딩 될 때 유효성이 검사되지만 연결된 필드에 `@Valid`로 주석을 추가하는 것이 좋습니다.

This ensure that validation is triggered even if no nested properties are found.
이렇게 하면 중첩 된 속성이 없는 경우에도 유효성 검사가 트리거됩니다.

The following example builds on the preceding `AcmeProperties` example:
다음 예제는 앞의 `AcmeProperties` 예제를 기반으로합니다.

```java
@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

	@NotNull
	private InetAddress remoteAddress;

	@Valid
	private final Security security = new Security();

	// ... getters and setters

	public static class Security {

		@NotEmpty
		public String username;

		// ... getters and setters

	}

}
```

You can also add a custom Spring `Validator` by creating a bean definition called `configurationPropertiesValidator`.
`configurationPropertiesValidator`라는 bean 정의를 생성하여 커스텀 Spring `Validator`를 추가 할 수 도있다.

The `@Bean` method should be declared `static`.
`@Bean` 메서드는 `정적`으로 선언되어야 합니다.

The configuration properties validator is created very early in the application’s lifecycle, and declaring the `@Bean` method as static lets the bean be created without having to instantiate the `@Configuration` class.
구성 등록 정보 유효성 validator는 응용 프로그램의 수명주기 초기에 만들어지며 `@Bean` 메서드를 정적으로 선언하면 `@Configuration` 클래스를 인스턴스화하 지 않고도 Bean을 만들 수 있습니다.

Doing so avoids any problems that may be caused by early instantiation.
이렇게 하면 초기 인스턴스 생성으로 인해 발생 할 수있는 문제를 피 할 수 있습니다.

There is a [property validation sample](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-samples/spring-boot-sample-property-validation) that shows how to set things up.
설정하는 방법을 보여주는 [속성 유효성 검사 샘플](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-samples/spring-boot-sample-property-validation)이 있습니다.

>:bulb:
The `spring-boot-actuator` module includes an endpoint that exposes all `@ConfigurationProperties` beans.
`spring-boot-actuator` 모듈은 모든 `@ConfigurationProperties` 빈을 노출하는 엔드 포인트를 포함합니다.

Point your web browser to `/actuator/configprops` or use the equivalent JMX endpoint.
웹 브라우저에서 `/ actuator / configprops`를 가리 키거나 해당 JMX 엔드 포인트를 사용하십시오.

See the ["Production ready features"](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html) section for details.
자세한 내용은 ["Production ready features"](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html)을 참조하십시오.

####24.8.6 @ConfigurationProperties vs. @Value
The `@Value` annotation is a core container feature, and it does not provide the same features as type-safe configuration properties.
`@Value` annotation은 핵심 컨테이너 기능이며 형식 안전(type-safe) 구성 속성과 동일한 기능을 제공하지 않습니다.

The following table summarizes the features that are supported by @ConfigurationProperties and @Value:
다음 표는 `@ConfigurationProperties` 및 `@Value`가 지원하는 기능을 요약 한 것입니다.

| Feature  | `@ConfigurationProperties`  | `@Value`  |
|---|:-:|:-:|
| [Relaxed binding](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding)  | Yes  | No  |
| [Meta-data support](https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html)  |  Yes | No  |
| `SpEL` evaluation  | No  | Yes  |

> [MarkDown Table generator site](https://www.tablesgenerator.com/markdown_tables)

If you define a set of configuration keys for your own components, we recommend you group them in a POJO annotated with `@ConfigurationProperties`.
자신의 components에 대한 구성 keys 세트를 정의하는 경우, `@ConfigurationProperties` annotation으로 주석 처리 된 POJO로 그룹화하는 것이 좋습니다.

You should also be aware that, since `@Value` does not support relaxed binding, it is not a good candidate if you need to provide the value by using environment variables.
또한 `@Value`는 완화 된 바인딩을 지원하지 않으므로 환경 변수를 사용하여 값을 제공해야하는 경우에는 좋지 않습니다.

Finally, while you can write a `SpEL` expression in `@Value`, such expressions are not processed from [application property files](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files).
마지막으로 `@Value`에 `SpEL` 식을 쓸 수는 있지만 이러한 표현식은 [응용 프로그램 속성 파일](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files)에서 처리되지 않습니다.